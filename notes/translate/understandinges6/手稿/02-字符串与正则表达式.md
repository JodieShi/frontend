# 字符串和正则表达式
字符串可以说是编程中最重要的数据类型之一。它们存在于几乎每个高级编程语言，能够高效使用字符串是开发者创建有用程序的基础。作为扩展，正则表达式也很重要，因为它们为开发者提供了使用字符串的额外能力。考虑到这些事实，ECMAScript 6创建人员通过新增能力和长期缺失的功能改进了字符串和字符串。本章将介绍这两种类型的改变。
## 更好的Unicode支持
在ECMAScript 6之前，JavaScript字符串围绕着16位字符编码（UTF-16）展开。每个16-bit序列为一个代表字符的*码元(code unit)*。所有的属性和方法，如`length`属性和`charAt()`方法，都是基于这些16-bit码元的。当然，16位曾经是足够包含所有字符的。然而由于Unicode带来的字符扩展集，它不再足以表示所有字符。
### UTF-16码点
限制字符长度为16位无法满足Unicode的为世上每个字符提供一个全局唯一标识符的目标。这些全局唯一标识符，即*码点(code point)*，为从0开始的数字。你可以认为码点是字符编码，每个数字代表一个字符。一个字符编码需要首先将码点编码为码元来保持内部一致性。对于UTF-16来说，码点由许多码元组成。
UTF-16中开始的2^16个码点由单独的16位码元表示。该范围被称为*基本多语言面（Basic Multilingual Plane, BMP）*。除此之外的一切都被认为是*增补面(supplementary planes)*中的一部分，它不再只由16位表示。UTF-16通过引入*代理对(surrogate pairs)*来解决该问题，它使用两个16位码元来表示一个独立码点。这表明字符串中的任何一个独立字符可以通过一个共16位的表示BMP字符的码元或两个共32位的表示增补字符的码元来表示。
在ECMAScript 5中，所有字符操作都在16位码元基础上工作，这表明在处理包含代理对的UTF-16编码字符串时可能会获得意料之外的结果，如下例所示：
```
vat text = "𠮷";

console.log(text.length);         // 2
console.log(/^.$/.texst(text));   // false
console.log(text.chatAt(0));      // ""
console.log(text.charAt(1);       // ""
console.log(text.charCodeAt(0));  // 55362
console.log(text.charCodeAt(1));  // 57271
```
独立Unicode字符`"𠮷"`由代理对来表示，这样，上述的JavaScript字符串操作将字符串视作两个16位字符。这表明：
- `text`的`length`为2，但它应该为1。
- 一个意在匹配单个字符的正则表达式匹配失败，因为它认为这是两个字符。
- `chatAt()`方法无法返回有效字符串，因为这两个16位都无对应的可打印字符。
`charCodeAt()`方法也不能正确识别出该字符。它正确返回每个码元的16位数字，它是最接近于在ECMAScript 5中获取`text`真实值的方法。
另一方面，ECMAScript 6强制进行UTF-16字符编码来解决此类问题。基于这种字符编码的标准化字符操作表明JavaScript可以支持专门用于代理对的功能。本节剩余部分讨论一些该功能的关键例子。
### codePointAt()方法
ECMAScript 6中为完全支持UTF-16而新增的方法为`codePointAt()`方法。
### String.fromCodePoint()方法
### normalize()方法
### 正则表达式的u标识
#### 活动中的u标识
#### 码点计数
#### 确定u标识支持
## 其它字符串变化
### 子字符串识别方法
### repeat()方法
## 其它正则表达式变化
### 正则表达式的y标识
### 正则表达式复制
### `flags`属性
## 模板字面量
### 基础语法
### 多行字符串
#### 前ECMAScript 6解决方案
#### 多行字符串简单方法
### 替换
### 带标签模板
#### 定义标签
#### 在模板字符串中使用原始值
## 总结
