# 字符串和正则表达式
字符串可以说是编程中最重要的数据类型之一。它们存在于几乎每个高级编程语言，能够高效使用字符串是开发者创建有用程序的基础。作为扩展，正则表达式也很重要，因为它们为开发者提供了使用字符串的额外能力。考虑到这些事实，ECMAScript 6创建人员通过新增能力和长期缺失的功能改进了字符串和字符串。本章将介绍这两种类型的改变。
## 更好的Unicode支持
在ECMAScript 6之前，JavaScript字符串围绕着16位字符编码（UTF-16）展开。每个16-bit序列为一个代表字符的*码元(code unit)*。所有的属性和方法，如`length`属性和`charAt()`方法，都是基于这些16-bit码元的。当然，16位曾经是足够包含所有字符的。然而由于Unicode带来的字符扩展集，它不再足以表示所有字符。
### UTF-16码点
限制字符长度为16位无法满足Unicode的为世上每个字符提供一个全局唯一标识符的目标。这些全局唯一标识符，即*码点(code point)*，为从0开始的数字。你可以认为码点是字符编码，每个数字代表一个字符。一个字符编码需要首先将码点编码为码元来保持内部一致性。对于UTF-16来说，码点由许多码元组成。
UTF-16中开始的2^16个码点由单独的16位码元表示。该范围被称为*基本多语言面（Basic Multilingual Plane, BMP）*。除此之外的一切都被认为是*增补面(supplementary planes)*中的一部分，它不再只由16位表示。UTF-16通过引入*代理对(surrogate pairs)*来解决该问题，它使用两个16位码元来表示一个独立码点。这表明字符串中的任何一个独立字符可以通过一个共16位的表示BMP字符的码元或两个共32位的表示增补字符的码元来表示。
在ECMAScript 5中，所有字符操作都在16位码元基础上工作，这表明在处理包含代理对的UTF-16编码字符串时可能会获得意料之外的结果，如下例所示：
```
vat text = "𠮷";

console.log(text.length);         // 2
console.log(/^.$/.texst(text));   // false
console.log(text.chatAt(0));      // ""
console.log(text.charAt(1);       // ""
console.log(text.charCodeAt(0));  // 55362
console.log(text.charCodeAt(1));  // 57271
```
独立Unicode字符`"𠮷"`由代理对来表示，这样，上述的JavaScript字符串操作将字符串视作两个16位字符。这表明：
- `text`的`length`为2，但它应该为1。
- 一个意在匹配单个字符的正则表达式匹配失败，因为它认为这是两个字符。
- `chatAt()`方法无法返回有效字符串，因为这两个16位都无对应的可打印字符。
`charCodeAt()`方法也不能正确识别出该字符。它正确返回每个码元的16位数字，它是最接近于在ECMAScript 5中获取`text`真实值的方法。
另一方面，ECMAScript 6强制进行UTF-16字符编码来解决此类问题。基于这种字符编码的标准化字符操作表明JavaScript可以支持专门用于代理对的功能。本节剩余部分讨论一些该功能的关键例子。
### codePointAt()方法
ECMAScript 6中为完全支持UTF-16而新增的方法为`codePointAt()`方法，它获取映射到字符串中指定位置的Unicode码点。该方法接收码元位置而不是字符位置，并返回一个整数值，如下例中的`console.log()`所示：
```
var text = "𠮷a"
console.log(text.charCodeAt(0));   // 53362
console.log(text.charCodeAt(1));   // 57271
console.log(text.charCodeAt(2));   // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```
除非处理的是非BMP字符，否则`codePointAt()`方法与`charCodeAt()`返回相同的值。`text`中的第一个字符是非BMP字符，因此由两个码元组成，说明它的`length`属性值是3而不是2。`charCodeAt()`方法在位置为0上只返回第一个码元，但`codePointAt()`返回完整的码点，即使该码点跨了多个码元。两个方法在位置为1（第一个字符的第二个码点）和2（字符`"a"`）上返回相同的值。
在字符上调用`codePointAt()`方法是判断该字符是由一个或两个码元表示的最简单方法。这里有一个你可以写来进行检查的方法：
```
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}
console.log(is32Bit("𠮷"));    // true
console.log(is32Bit("a"));    // false
```
16比特字符的上限用16进制表示是`FFFF`，因此任何大于该数的码点都是被两个码元表示的，总共32比特。
### String.fromCodePoint()方法
当ECMAScript提供了做某事的方法时，它总会提供一种做反向的事的方法。你可以使用`codePointAt()`来获取字符串中某个字符的码点，也可以用`String.fromCodePoint()`来构造一个给定码点的单字符字符串。例如：
```
console.log(String.fromCodePoint(134071));  // "𠮷"
```
可以将`String.fromCodePoint()`看作`String.fromCharCode()`方法的一种更完备的版本。它们为BMP中的所有字符返回相同的结果。唯一区别在于当你传入BMP之外的字符的码点时。
### normalize()方法
Unicode的另一个有趣的地方在于：当为了排序或其他基于比较的操作时，不同的字符可能会被认为是相等的。有两种方法来定义这种行为。第一种是*规范对等（canonical equivalence）*，表明在所有方面，两个码点序列被认为是可以互换的。例如，两个字符的组合可以与一个字符是规范对等的。另一种关系是*兼容性（compatibility）*。两个可兼容的码点序列看起来是不同的但是可以在某些场景下互换。
由于以上关系，两个基本上表示相同文本的字符串可能包含不同的码点序列。例如：字符"æ"与字符串"ae"可以被互换使用，但并不是严格相等的，除非使用某些方法规范化。
ECMAScript6通过为字符串提供一个`normalize()`方法来支持Unicode的规范化形式。该方法接收一个可选的字符串参数，它表明使用以下可用的Unicode规范化形式之一：
* 默认值，标准等价合成（`"NFC"`）
* 标准等价分解（`"NFD"`）
* 兼容等价分解（`"NFKC"`）
* 兼容等价分解（`"NFKD"`）
解释这四种形式的差别超出了本书的范围。只需记住当比较字符串时，两个字符串必需首先被规范化为相同的形式。例如：
```
var normalized = values.map(function(text) {
  return text.normalize();
});

normalized.sort(function(first, second) {
  if (first < second) {
    return -1;
  } else if (first === second) {
    return 0;
  } else {
    return 1;
  }
});
```
这段代码转换`values`数组中的字符串为规范化形式，因此数组可以被正确地排序。你也可以在比较函数中调用`normalize()`函数来为原始数组排序，如下：
values.sort(function(first, second) {
  var firstNormalized = first.normalize(),
      secondNormalized = second.normalize();
  
  if (firstNormalized < secondNormalized) {
    return -1;
  } else if (firstNormalized === secondNormalized) {
    return 0;
  } else {
    return 1;
  }
});
再次注意，关于这段代码需要注意的最重要的地方是`first`和`second`使用了相同方式来规范化。本例中使用了默认值，NFC，但是你可以向下面一样轻松地指定另外的值：
```
values.sort(function(first, second) {
  var firstNormalized = first.normalize('NFD'),
      secondNormalized = second.normalize('NFD');
  
  if (firstNormalized < secondNormalized) {
    return -1;
  } else if (firstNormalized === secondNormalized) {
    return 0;
  } else {
    return 1;
  }
});
```
如果你之前不曾担心过Unicode规范化，那么你现在可能不会过多使用这个方法。但是如果你曾经在一个国家化应用中工作，你一定会发现`normalize()`方法非常有用。
然而，ECMAScript6提供的关于处理Unicode字符串的改进不仅仅是方法。标准还增加了两个有用的语法元素。
### 正则表达式的u标识
你可以通过正则表达式来完成许多常见的字符串操作。但是记住，正则表达式假设16比特码元，每个表示一个单个字符。为了解决这个问题，ECMAScript6为正则表达式定义了一个`u`标识，代表Unicode。
#### 活动中的u标识
当一个正则表达式设置了`u`标识，它切换到按字符工作的模式，而不是按码元。这表明正则表达式不应再为字符串中的代理对而感到迷惑，并且应该按预想的方式工作。例如，考虑以下代码：
```
var text = "𠮷";
console.log(text.length);   // 2
console.log(/^.$/.test(text));  // false
console.log(/^.$/u.test(text));  // true
```
正则表达式`/^.$/`可以匹配输入的任一单个字符的字符串。当它不使用`u`标识时，正则表达式匹配码元，因此日语字符（由两个码元表示）无法匹配该字符串。当使用`u`标识时，正则表达式比较字符而不是码元，因此日语字符可以匹配。
#### 码点计数
不幸的是，ECMAScript6并未新增判断一个字符串中有多少个码点的方法，但是通过`u`标识，你可以使用正则表达式来计算它，如下：
```
function codePointLength(text) {
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}
console.log(codePointLength("abc"));   // 3
console.log(codePointLength("𠮷bc"));   // 3
```
该例通过一个全局应用并且启用Unicode的正则表达式来调用`match()`方法来检查`text`中的所有空格和非空格字符串（使用`[\s\S]`来确保模式可以匹配到新的行）。当至少有一个匹配项时，`result`含一个匹配项数组，所以数组的长度为字符串中的码点数量。在Unicode中，"abc"和"𠮷bc"都含有三个字符，因此数组长度是3。
虽然这种方法有效，但它并不是很快，尤其是应用到一个长字符串时。你也可以使用一个字符串迭代器（第8章中将介绍）。一般来说，当可以时尽量最小化码点计数。
#### 确定u标识支持
由于`u`标识是一个语法变化，在不兼容ECMAScript6的JavaScript引擎中试图使用它会抛出一个语法错误。最安全的做法是通过一个函数来判断`u`标识是否被支持，如下：
```
function hasRegExpU() {
  try {
    var pattern = new RegExp(".", "u")
    return true;
  } catch(ex) {
    return false;
  }
}
```
该函数使用`RegExp`构造函数来将`u`标识作为一个参数传入。该方法在老的JavaScript引擎中也是有效的，但构造函数将在`u`不被支持的时候抛出一个错误。
如果你的代码仍需要在老的JavaScript引擎中工作，那么总是在使用`u`标识的时候使用`RegExp`构造函数。这将避免语法错误并允许你可选地在不终止程序执行的情况下检测和使用`u`标识。
## 其它字符串变化
JavaScript字符串总是落后于其他语言的相似特性。直到ECMAScript5，字符串才终于实现了`trim()`方法，ECMAScript6继续扩展JavaScript的能力来使用新的方法解析字符串。
### 子字符串识别方法
自从JavaScript首次被引入以来，开发人员一直使用`indexOf()`函数来识别其他字符串中的字符串。ECMAScript6包含了以下三个方法，它们被设计为专门用来做这件事：
* `includes()`方法在字符串中任意位置可以找到给定文本时返回true，否则返回false。
* `startsWith()`方法在字符串开头找到给定文本时返回true，否则返回false。
* `endsWith()`方法在字符串结尾找到给定文本时返回true，否则返回false。
每个方法接收两个参数：待搜索的文本和一个可选的索引。当提供了第二个参数时，`includes()`和`startsWith()`从该索引位开始匹配而`endsWith()`从第二个参数减去第一个参数的长度处开始匹配。当第二个参数未提供时，`includes()`和`startsWith()`从字符串开始的位置匹配而`endsWith()`从结尾处匹配。效率上来说，第二个参数减小了字符串被搜索的量。以下为几个演示这三个方法的例子：
```
var msg = "Hello world!";

console.log(msg.startsWith("Hello"));  // true
console.log(msg.endsWith("!"));  // true
console.log(msg.includes("o"));  // true

console.log(msg.startsWith("o"));  // false
console.log(msg.endsWith("world!"));  // true
console.log(msg.includes("x"));  // false

console.log(msg.startsWith("o", 4));  // true
console.log(msg.endsWith("o", 8));  // true
console.log(msg.includes("o", 8));  // false
```
开始的六个调用不包括第二个参数，所以如果需要它们将搜索整个字符串。最后三个调用只检查字符串的部分。`msg.startsWith("o", 4)`从`msg`字符串的索引位置4开始匹配，即"Hello"中的"o"。`msg.endsWith("o", 8)`从`msg`字符串的索引位置7开始匹配（第二个参数减去第一个参数的长度），即"world"中的"o"。`msg.includes("o", 8)`从索引位置8开始匹配，即"world"中的"r"。
虽然这三个方法使得识别子字符串的存在更为简单，但它们只返回一个布尔值。如果你需要找到一个字符串在另一个中的实际位置，需要使用`indexOf()`或者`lastIndexOf()`方法。
`startsWith()`，`endsWith()`和`includes()`方法将在你传入一个正则表达式而不是字符串时抛出一个错误。这与`indexOf()`和`lastIndexOf()`相反，它们将正则表达式参数转换为一个字符串并搜索该字符串。
### repeat()方法
ECMAScript6还为字符串新增了一个`repeat()`方法，它接收字符串重复的次数作为参数。它返回源字符串重复指定次数后的字符串。例如：
```
console.log("x".repeat(3));   // "xxx"
console.log("hello".repeat(2));   // "hellohello"
console.log("abc".repeat(4));   // "abcabcabcabc"
```
该方法是所有其他方法的便利方法，它在处理文本时可能特别有用。它在需要创建缩进层级的代码格式化工具中格外有用，如下：
```
// 使用指定数量的空格来缩进
var indent = " ".repeat(4),
    indentLevel = 0;

// 当增加缩进层级时
var newIndent = indent.repeat(++indentLevel);
```
第一个`repeat()`调用创建了一个四个空格的字符串，而`indentLevel`变量用来追踪缩进的层级。接着，你只需使用`repeat()`和自增的`indentLevel`来改变空格的数量。

ECMAScript6还对不属于特定类别的正则表达式功能进行了一些有用的修改。下一节将重点介绍一些。
## 其它正则表达式变化
### 正则表达式的y标识
### 正则表达式复制
### `flags`属性
## 模板字面量
### 基础语法
### 多行字符串
#### 前ECMAScript 6解决方案
#### 多行字符串简单方法
### 替换
### 带标签模板
#### 定义标签
#### 在模板字符串中使用原始值
## 总结
