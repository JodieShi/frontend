# 字符串和正则表达式
字符串可以说是编程中最重要的数据类型之一。它们存在于几乎每个高级编程语言，能够高效使用字符串是开发者创建有用程序的基础。作为扩展，正则表达式也很重要，因为它们为开发者提供了使用字符串的额外能力。考虑到这些事实，ECMAScript 6创建人员通过新增能力和长期缺失的功能改进了字符串和字符串。本章将介绍这两种类型的改变。
## 更好的Unicode支持
在ECMAScript 6之前，JavaScript字符串围绕着16位字符编码（UTF-16）展开。每个16-bit序列为一个代表字符的*码元(code unit)*。所有的属性和方法，如`length`属性和`charAt()`方法，都是基于这些16-bit码元的。当然，16位曾经是足够包含所有字符的。然而由于Unicode带来的字符扩展集，它不再足以表示所有字符。
### UTF-16码点
限制字符长度为16位无法满足Unicode的为世上每个字符提供一个全局唯一标识符的目标。这些全局唯一标识符，即*码点(code point)*，为从0开始的数字。你可以认为码点是字符编码，每个数字代表一个字符。一个字符编码需要首先将码点编码为码元来保持内部一致性。对于UTF-16来说，码点由许多码元组成。
UTF-16中开始的2^16个码点由单独的16位码元表示。该范围被称为*基本多语言面（Basic Multilingual Plane, BMP）*。除此之外的一切都被认为是*增补面(supplementary planes)*中的一部分，它不再只由16位表示。UTF-16通过引入*代理对(surrogate pairs)*来解决该问题，它使用两个16位码元来表示一个独立码点。这表明字符串中的任何一个独立字符可以通过一个共16位的表示BMP字符的码元或两个共32位的表示增补字符的码元来表示。
在ECMAScript 5中，所有字符操作都在16位码元基础上工作，这表明在处理包含代理对的UTF-16编码字符串时可能会获得意料之外的结果，如下例所示：
```
vat text = "𠮷";

console.log(text.length);         // 2
console.log(/^.$/.texst(text));   // false
console.log(text.chatAt(0));      // ""
console.log(text.charAt(1);       // ""
console.log(text.charCodeAt(0));  // 55362
console.log(text.charCodeAt(1));  // 57271
```
独立Unicode字符`"𠮷"`由代理对来表示，这样，上述的JavaScript字符串操作将字符串视作两个16位字符。这表明：
- `text`的`length`为2，但它应该为1。
- 一个意在匹配单个字符的正则表达式匹配失败，因为它认为这是两个字符。
- `chatAt()`方法无法返回有效字符串，因为这两个16位都无对应的可打印字符。
`charCodeAt()`方法也不能正确识别出该字符。它正确返回每个码元的16位数字，它是最接近于在ECMAScript 5中获取`text`真实值的方法。
另一方面，ECMAScript 6强制进行UTF-16字符编码来解决此类问题。基于这种字符编码的标准化字符操作表明JavaScript可以支持专门用于代理对的功能。本节剩余部分讨论一些该功能的关键例子。
### codePointAt()方法
ECMAScript 6中为完全支持UTF-16而新增的方法为`codePointAt()`方法，它获取映射到字符串中指定位置的Unicode码点。该方法接收码元位置而不是字符位置，并返回一个整数值，如下例中的`console.log()`所示：
```
var text = "𠮷a"
console.log(text.charCodeAt(0));   // 53362
console.log(text.charCodeAt(1));   // 57271
console.log(text.charCodeAt(2));   // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```
除非处理的是非BMP字符，否则`codePointAt()`方法与`charCodeAt()`返回相同的值。`text`中的第一个字符是非BMP字符，因此由两个码元组成，说明它的`length`属性值是3而不是2。`charCodeAt()`方法在位置为0上只返回第一个码元，但`codePointAt()`返回完整的码点，即使该码点跨了多个码元。两个方法在位置为1（第一个字符的第二个码点）和2（字符`"a"`）上返回相同的值。
在字符上调用`codePointAt()`方法是判断该字符是由一个或两个码元表示的最简单方法。这里有一个你可以写来进行检查的方法：
```
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}
console.log(is32Bit("𠮷"));    // true
console.log(is32Bit("a"));    // false
```
16比特字符的上限用16进制表示是`FFFF`，因此任何大于该数的码点都是被两个码元表示的，总共32比特。
### String.fromCodePoint()方法
当ECMAScript提供了做某事的方法时，它总会提供一种做反向的事的方法。你可以使用`codePointAt()`来获取字符串中某个字符的码点，也可以用`String.fromCodePoint()`来构造一个给定码点的单字符字符串。例如：
```
console.log(String.fromCodePoint(134071));  // "𠮷"
```
可以将`String.fromCodePoint()`看作`String.fromCharCode()`方法的一种更完备的版本。它们为BMP中的所有字符返回相同的结果。唯一区别在于当你传入BMP之外的字符的码点时。
### normalize()方法
Unicode的另一个有趣的地方在于：当为了排序或其他基于比较的操作时，不同的字符可能会被认为是相等的。有两种方法来定义这种行为。第一种是*规范对等（canonical equivalence）*，表明在所有方面，两个码点序列被认为是可以互换的。例如，两个字符的组合可以与一个字符是规范对等的。另一种关系是*兼容性（compatibility）*。两个可兼容的码点序列看起来是不同的但是可以在某些场景下互换。
由于以上关系，两个基本上表示相同文本的字符串可能包含不同的码点序列。例如：字符"æ"与字符串"ae"可以被互换使用，但并不是严格相等的，除非使用某些方法规范化。
ECMAScript6通过为字符串提供一个`normalize()`方法来支持Unicode的规范化形式。该方法接收一个可选的字符串参数，它表明使用以下可用的Unicode规范化形式之一：
* 默认值，标准等价合成（`"NFC"`）
* 标准等价分解（`"NFD"`）
* 兼容等价分解（`"NFKC"`）
* 兼容等价分解（`"NFKD"`）
解释这四种形式的差别超出了本书的范围。只需记住当比较字符串时，两个字符串必需首先被规范化为相同的形式。例如：
```
var normalized = values.map(function(text) {
  return text.normalize();
});

normalized.sort(function(first, second) {
  if (first < second) {
    return -1;
  } else if (first === second) {
    return 0;
  } else {
    return 1;
  }
});
```
这段代码转换`values`数组中的字符串为规范化形式，因此数组可以被正确地排序。你也可以在比较函数中调用`normalize()`函数来为原始数组排序，如下：
values.sort(function(first, second) {
  var firstNormalized = first.normalize(),
      secondNormalized = second.normalize();
  
  if (firstNormalized < secondNormalized) {
    return -1;
  } else if (firstNormalized === secondNormalized) {
    return 0;
  } else {
    return 1;
  }
});
再次注意，关于这段代码需要注意的最重要的地方是`first`和`second`使用了相同方式来规范化。本例中使用了默认值，NFC，但是你可以向下面一样轻松地指定另外的值：
```
values.sort(function(first, second) {
  var firstNormalized = first.normalize('NFD'),
      secondNormalized = second.normalize('NFD');
  
  if (firstNormalized < secondNormalized) {
    return -1;
  } else if (firstNormalized === secondNormalized) {
    return 0;
  } else {
    return 1;
  }
});
```
如果你之前不曾担心过Unicode规范化，那么你现在可能不会过多使用这个方法。但是如果你曾经在一个国家化应用中工作，你一定会发现`normalize()`方法非常有用。
然而，ECMAScript6提供的关于处理Unicode字符串的改进不仅仅是方法。标准还增加了两个有用的语法元素。
### 正则表达式的u标识
你可以通过正则表达式来完成许多常见的字符串操作。但是记住，正则表达式假设16比特码元，每个表示一个单个字符。为了解决这个问题，ECMAScript6为正则表达式定义了一个`u`标识，代表Unicode。
#### 活动中的u标识
当一个正则表达式设置了`u`标识，它切换到按字符工作的模式，而不是按码元。这表明正则表达式不应再为字符串中的代理对而感到迷惑，并且应该按预想的方式工作。例如，考虑以下代码：
```
var text = "𠮷";
console.log(text.length);   // 2
console.log(/^.$/.test(text));  // false
console.log(/^.$/u.test(text));  // true
```
正则表达式`/^.$/`可以匹配输入的任一单个字符的字符串。当它不使用`u`标识时，正则表达式匹配码元，因此日语字符（由两个码元表示）无法匹配该字符串。当使用`u`标识时，正则表达式比较字符而不是码元，因此日语字符可以匹配。
#### 码点计数
不幸的是，ECMAScript6并未新增判断一个字符串中有多少个码点的方法，但是通过`u`标识，你可以使用正则表达式来计算它，如下：
```
function codePointLength(text) {
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}
console.log(codePointLength("abc"));   // 3
console.log(codePointLength("𠮷bc"));   // 3
```
该例通过一个全局应用并且启用Unicode的正则表达式来调用`match()`方法来检查`text`中的所有空格和非空格字符串（使用`[\s\S]`来确保模式可以匹配到新的行）。当至少有一个匹配项时，`result`含一个匹配项数组，所以数组的长度为字符串中的码点数量。在Unicode中，"abc"和"𠮷bc"都含有三个字符，因此数组长度是3。
虽然这种方法有效，但它并不是很快，尤其是应用到一个长字符串时。你也可以使用一个字符串迭代器（第8章中将介绍）。一般来说，当可以时尽量最小化码点计数。
#### 确定u标识支持
由于`u`标识是一个语法变化，在不兼容ECMAScript6的JavaScript引擎中试图使用它会抛出一个语法错误。最安全的做法是通过一个函数来判断`u`标识是否被支持，如下：
```
function hasRegExpU() {
  try {
    var pattern = new RegExp(".", "u")
    return true;
  } catch(ex) {
    return false;
  }
}
```
该函数使用`RegExp`构造函数来将`u`标识作为一个参数传入。该方法在老的JavaScript引擎中也是有效的，但构造函数将在`u`不被支持的时候抛出一个错误。
如果你的代码仍需要在老的JavaScript引擎中工作，那么总是在使用`u`标识的时候使用`RegExp`构造函数。这将避免语法错误并允许你可选地在不终止程序执行的情况下检测和使用`u`标识。
## 其它字符串变化
JavaScript字符串总是落后于其他语言的相似特性。直到ECMAScript5，字符串才终于实现了`trim()`方法，ECMAScript6继续扩展JavaScript的能力来使用新的方法解析字符串。
### 子字符串识别方法
自从JavaScript首次被引入以来，开发人员一直使用`indexOf()`函数来识别其他字符串中的字符串。ECMAScript6包含了以下三个方法，它们被设计为专门用来做这件事：
* `includes()`方法在字符串中任意位置可以找到给定文本时返回true，否则返回false。
* `startsWith()`方法在字符串开头找到给定文本时返回true，否则返回false。
* `endsWith()`方法在字符串结尾找到给定文本时返回true，否则返回false。
每个方法接收两个参数：待搜索的文本和一个可选的索引。当提供了第二个参数时，`includes()`和`startsWith()`从该索引位开始匹配而`endsWith()`从第二个参数减去第一个参数的长度处开始匹配。当第二个参数未提供时，`includes()`和`startsWith()`从字符串开始的位置匹配而`endsWith()`从结尾处匹配。效率上来说，第二个参数减小了字符串被搜索的量。以下为几个演示这三个方法的例子：
```
var msg = "Hello world!";

console.log(msg.startsWith("Hello"));  // true
console.log(msg.endsWith("!"));  // true
console.log(msg.includes("o"));  // true

console.log(msg.startsWith("o"));  // false
console.log(msg.endsWith("world!"));  // true
console.log(msg.includes("x"));  // false

console.log(msg.startsWith("o", 4));  // true
console.log(msg.endsWith("o", 8));  // true
console.log(msg.includes("o", 8));  // false
```
开始的六个调用不包括第二个参数，所以如果需要它们将搜索整个字符串。最后三个调用只检查字符串的部分。`msg.startsWith("o", 4)`从`msg`字符串的索引位置4开始匹配，即"Hello"中的"o"。`msg.endsWith("o", 8)`从`msg`字符串的索引位置7开始匹配（第二个参数减去第一个参数的长度），即"world"中的"o"。`msg.includes("o", 8)`从索引位置8开始匹配，即"world"中的"r"。
虽然这三个方法使得识别子字符串的存在更为简单，但它们只返回一个布尔值。如果你需要找到一个字符串在另一个中的实际位置，需要使用`indexOf()`或者`lastIndexOf()`方法。
`startsWith()`，`endsWith()`和`includes()`方法将在你传入一个正则表达式而不是字符串时抛出一个错误。这与`indexOf()`和`lastIndexOf()`相反，它们将正则表达式参数转换为一个字符串并搜索该字符串。
### repeat()方法
ECMAScript6还为字符串新增了一个`repeat()`方法，它接收字符串重复的次数作为参数。它返回源字符串重复指定次数后的字符串。例如：
```
console.log("x".repeat(3));   // "xxx"
console.log("hello".repeat(2));   // "hellohello"
console.log("abc".repeat(4));   // "abcabcabcabc"
```
该方法是所有其他方法的便利方法，它在处理文本时可能特别有用。它在需要创建缩进层级的代码格式化工具中格外有用，如下：
```
// 使用指定数量的空格来缩进
var indent = " ".repeat(4),
    indentLevel = 0;

// 当增加缩进层级时
var newIndent = indent.repeat(++indentLevel);
```
第一个`repeat()`调用创建了一个四个空格的字符串，而`indentLevel`变量用来追踪缩进的层级。接着，你只需使用`repeat()`和自增的`indentLevel`来改变空格的数量。

ECMAScript6还对不属于特定类别的正则表达式功能进行了一些有用的修改。下一节将重点介绍一些。
## 其它正则表达式变化
正则表达式是JavaScript中用于处理字符串的一个重要部分，如该语言其他许多部分一样，在最近的版本中它并没有发生许多变化。然而，为了配合字符串的更新，ECMAScript6做了一些对正则表达式的改进。
### 正则表达式的y标识
在Firefox将`y`标识作为正则表达式的专有扩展实现之后，ECMAScript6对其进行了标准化。`y`标识影响了一个正则表达式搜索的`粘性（sticky）`，它告诉搜索应从由正则表达式的`lastIndex`属性指定的位置开始匹配字符串中的字符。如果该位置没有匹配项，那么正则表达式停止匹配。为了了解它是如何工作的，请看下面的例子：
```
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);  // "hello1 "
console.log(globalResult[0]);  // "hello1 "
console.log(stickyResult[0]);  // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);  // "hello1 "
console.log(globalResult[0]);  // "hello2 "
console.log(stickyResult[0]);  // "Error! stickyResult is null"
```
该例中有三个正则表达式。表达式`pattern`中没有标识，`globalPattern`使用了`g`标识，`stickyPattern`使用了`y`标识。在`console.log()`的第一个三次调用时，三个正则表达都应该返回`"hello1 "`，结尾处有一个空格。
之后，`lastIndex`属性在三个模式上都改为了1，表示正则表达式应该从它们的第二个字符串开始匹配。无标识符的正则表达式完全忽略`lastIndex`的改变并不出意外地匹配到`"hello1 "`。有`g`标识符的正则表达式则继续匹配到`"hello2 "`，因为它从字符串的第二个字符（`"e"`）开始搜索。粘性正则表达式没有在第二个字符开始的位置匹配到任何项，因此`stickyResult`为`null`。
每次执行完操作，粘性标识符保存最近一次匹配的下一个字符的索引至`lastIndex`中。如果操作结果是并没有匹配到，那么`lastIndex`被设为0。全局标识也按相同的方式工作，如下所示：
```
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);  // "hello1 "
console.log(stickyResult[0]);  // "hello1 "
console.log(globalResult[0]);  // "hello1 "

console.log(pattern.lastIndex);  // 0
console.log(pattern.lastIndex);  // 7
console.log(pattern.lastIndex);  // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);  // "hello1 "
console.log(stickyResult[0]);  // "hello2 "
console.log(globalResult[0]);  // "hello2 "

console.log(pattern.lastIndex);  // 0
console.log(pattern.lastIndex);  // 14
console.log(pattern.lastIndex);  // 14
```
对于`stickyPattern`和`globalPattern`，`lastIndex`的值在第一次`exec()`调用后变为7，在第二次调用后变为14。
还有两个关于sticky标识符的细节需要记住：
1. `lastIndex`属性只在调用正则表达式对象的方法，如`exec()`和`test()`时才具备。传递一个正则表达式给字符串方法，如`match()`，不会导致粘性行为。
2. 当使用`^`符号来匹配字符串开头时，粘性正则表达式只从该字符串的开头开始匹配（或在多行模式下从一行的开头开始）。如果`lastIndex`是0，`^`使得粘性表达式与非粘性表达式并无不同。如果`lastIndex`并不在单行模式下指向字符串的开头或在多行模式下并不指向一行的开头，那么粘性表达式将永远不会匹配到。
像正则表达式的其他标识符一样，你可以通过一个属性来检测`y`标识符的存在。在这种情况下，你可以检查`sticky`属性，如下：
```
var pattern = /hello\d/y;
console.log(pattern.sticky);  // true
```
`sticky`属性在sticky标识存在时被设为true，否则为false。`sticky`属性是一个基于标识符存在性的只读属性，无法通过代码修改。
类似于`u`标识，`y`标识是一个语法变化，因此在老的JavaScript引擎中将引起语法错误。你可以使用下面的方法来检测支持：
```
function hasRegExpY() {
  try {
    var pattern = new RegExp(".", "y");
    return true;
  } catch(ex) {
    return false;
  }
}
```
类似于`u`检查，如果不能创建一个带`y`标识的正则表达式，它将返回false。最后一个与`u`标识符相同的地方在于，如果你需要在老的JavaScript引擎中运行使用`y`标识的代码，一定要用`RegExp`构造函数来定义这些正则表达式，这样可以避免语法错误。
### 正则表达式复制
在ECMAScript5中，你可以通过传递一个正则表达式给`RegExp`构造函数来复制它，如下：
```
var re1 = /ab/i,
    re2 = new RegExp(re1);
```
变量`re2`只是变量`re1`的一个副本。如果你为`RegExp`构造函数提供第二个参数，为该正则表达式指定标识符，那么你的代码将无法工作，如下例所示：
```
var re1 = /ab/i,
    // 在ES5中抛出一个错误，在ES6中正常
    re2 = new RegExp(re1, "g");
```
如果你在ECMAScrip5环境中执行这段代码，你将获得一个错误提示，声明当第一个参数为正则表达式时，第二个参数无法使用。ECMAScript6改变了这种行为，它允许第二个参数并将重写第一个参数中已存在的任何标识符。例如：
```
var re1 = /ab/i,
    // 在ES5中抛出一个错误，在ES6中正常
    re2 = new RegExp(re1, "g");

console.log(re1.toString());  // "/ab/i"
console.log(re2.toString());  // "/ab/g"

console.log(re1.test("ab"));  // true
console.log(re2.test("ab"));  // true

console.log(re1.test("AB"));  // true
console.log(re2.test("AB"));  // false
```
在该代码中，`re1`有一个大小写不敏感标识`i`而`re2`只有一个全局`g`标识。`RegExp`构造函数复制了`re1`的模式并将`i`标识替换成了`g`标识符。没有第二个参数时，`re2`将和`re1`拥有相同的标识符。
### `flags`属性
除了添加新的标识并改变标识的工作方式外，ECMAScript还新增了一个相关属性。在ECMAScript5中，你可以使用`source`属性来获得正则表达式的文本，然而为了获得标识符字符串，你需要解析`toString()`方法的输出，如下：
```
function getFlags(re) {
  var text = re.toString();
  return text.substring(text.lastIndexOf("/") + 1, text.length);
}

// toString()结果为"/ab/g"
var re = /ab/g
console.log(getFlags(re));  // "g"
```
它将一个正则表达式转换为字符串，并返回最后一个`/`后的字符。这些字符即为标识符。
ECMAScript6通过添加一个`flags`属性与`source`属性一起来使得获取标识符更简单。这两个属性都是仅分配了一个获取函数的原型访问器属性，这使得它们是只读的。`flags`属性使得为了调试或继承目的的正则表达式检查更为简单。
ECMAScript6最近添加的`flags`属性返回应用到正则表达式上的所有表达式的字符串表示。例如：
```
var re = /ab/g;

console.log(re.source);  // "ab"
console.log(re.flags);   // "g"
```
它获取`re`上的所有标识符并在控制台中打印它们，这比`toString()`方法少了很多行代码。一起使用`source`和`flags`属性可以让你在无需直接解析正则表达式字符串的情况下获得正则表达式片段。
本章中目前提到的字符串和正则表达式变化无疑是强大的，而ECMAScript6通过一种更大的方式提高了你对字符串的处理能力。它带来了一种字面量类型，使得字符串更为灵活。
## 模板字面量
### 基础语法
### 多行字符串
#### 前ECMAScript 6解决方案
#### 多行字符串简单方法
### 替换
### 带标签模板
#### 定义标签
#### 在模板字符串中使用原始值
## 总结
