# 对象功能扩展
ECMAScript6着重提升对象的实用性，因为JavaScript中几乎所有值都是某种类型的对象。此外，随着JavaScript应用复杂度的提升，平均每个JavaScript程序中的对象数持续上升，表明程序在不断创建更多的对象。更多的对象使得高效使用对象成为必需。
ECMAScript6以多种方法改进了对象，从简单语法扩展到操作和交互选项。
## 对象分类
JavaScript使用一种混合术语来描述在标准中发现的对象，而不是浏览器或Node.js等执行环境添加的，ECMAScript6标准对每个对象类型有明确的定义。理解这些术语对整体上更好地理解这个语言很重要。对象分类为：
* *普通对象* 具备JavaScript对象中所有默认内部行为。
* *外来对象* 具备在某些方面不同于默认值的内部行为。
* *标准对象* 是由ECMAScript6定义的那些，如`Array`, `Date`等。标准对象可能是普通的或者外来的。
* *内置对象* 当脚本开始执行时出现在JavaScript执行环境中。所有标准对象都是内置对象。
我将在本书中使用这些术语来解释ECMAScript6中定义的各种对象。
## 对象字面量语法扩展
对象字面量是JavaScript中最流行的模式之一。JSON建立在它自己的语法之上，并且几乎存在于互联网上的所有JavaScript文件中。对象字面量如此流行的原因在于它是一种创建对象的简单语法，否则将需要多行代码。对于开发者来说，幸运的是ECMAScript6通过用多种方法扩展语法来使得对象字面量更为强大且更为简洁。
### 属性初始化简写
在ECMAScript5及之前，对象字面量简单地为名称-值对的集合。这表明属性初始化时可能会有重复。例如：
```
function createPerson(name, age) {
  return {
    name: name,
    age: age
  };
}
```
`createPerson()`函数创建了一个对象，它的属性名和函数参数名相同。结果看起来像是`name`和`age`重复了，虽然其中一个时对象属性的名称，而另一个提供该属性的值。返回对象中的键`name`被赋予了变量`name`中的值，返回对象中的`age`被赋予了变量`age`中的值。
在ECMAScript6中，你可以使用*属性初始化*简写来消除存在于属性名和本地变量间的重复值。当一个对象的属性名与本地变量名相同时，你可以简单地包含这个名字而无需冒号和值。例如，`createPerson()`可以在ECMAScript6中被重写为如下形式：
```
function createPerson(name, age) {
  return {
    name,
    age
  };
}
```
当一个对象字面量的属性只有一个名字时，JavaScript引擎将在包含域中搜索一个同名的变量。如果可以找到，那么该变量的值被赋给对象字面量的同名属性。在这个例子中，对象字面量属性`name`被赋予本地变量`name`的值。
这个扩展使得对象字面量初始化更为简洁并帮助消除命名错误。在JavaScript中，将属性赋值为同名的本地变量是一个非常常见的模式，这使得该扩展成为一个很受欢迎的增补。
### 简写方法
ECMAScript6也改进了为对象字面量中的方法赋值的语法。在ECMAScript5及之前，你必须指定一个名称和一个完整的函数定义来为对象新增一个方法，如下：
```
var person = {
  name: "Nicholas",
  sayName: function() {
    console.log(this.name);
  }
};
```
在ECMAScript6中，语法被简化为去除冒号和关键字`function`。这表明你可以重写上述例子如下：
```
var person = {
  name: "Nicholas",
  sayName() {
    console.log(this.name);
  }
};
```
这种简写语法，也被称为*简写方法*语法，正如上个例子中一样为`person`对象创建了一个方法。`sayName()`属性被赋了一个匿名函数，它与ECMAScript5中的`sayName()`函数有着所有相同的特性。一个差别在于简写方法可能使用`super`（稍后在“使用super引用轻松访问原型”一节中讨论），而非简写方法无法使用。
使用简写方法语法创建的方法的`name`属性为括号前的名称。在上个例子中，`person.sayName()`的`name`属性为`"sayName"`。
### 计算属性名
ECMAScript5及之前可以计算对象实例的属性名称，如果这些属性是通过方括号而不是点号来设置的。方括号使得你可以通过变量和可能包含使用在标志符中会导致语法错误的字符的字符串字面量来指定属性名称。下面有一个例子：
```
var person = {},
    lastName = "last name";

person["first name"] = "Nicholas";
person[lastName] = "Zakas";

console.log(person["first name"]);   // "Nicholas"
console.log(person[lastName]);   // "Zakas"
```
由于`lastName`赋值为`"last name"`，本例中的两个属性名都使用了空格，使得无法通过点号来引用它们。然而，方括号允许任何字符串值被用作属性名，因此赋`"first name"`为`"Nicholas"`，赋`"last name"`为`"Zakas"`都是成功的。
进一步地，你可以直接使用字符串字面量作为对象字面量中的属性名，如下：
```
var person = {
  "first name": "Nicholas"
};

console.log(person["first name"]);  // "Nicholas"
```
该模式在提前知道属性名并且属性名可以通过字符串字面量表示时生效。如果属性名`"first name"`是包含在变量中的（如上一个例子）或者需要被计算，那么在ECMAScript5中将无法使用对象字面量来定义该属性。
在ECMAScript6中，计算属性名为对象字面量语法的一个部分，它也使用与引用对象实例中的计算属性名相同的方括号。例如：
```
var lastName = "last name";

var person = {
  "first name": "Nicholas",
  [lastName]: "Zakas"
};

console.log(person["first name"]);  // "Nicholas"
console.log(person[lastName]);  // "Zakas"
```
对象字面量中的方括号表明该属性名是计算来的，因此它的内容等价于一个字符串。这表明你可以包含如下的表达式：
```
var suffix = " name";

var person = {
  ["first" + suffix]: "Nicholas",
  ["last" + suffix]: "Zakas"
};

console.log(person["first name"]);  // "Nicholas"
console.log(person["last name"]);  // "Zakas"
```
这些属性计算为`"first name"`和`"last name"`，这些字符串可以后续被用来引用这些属性。任何你可以用来在对象实例中使用括号表示法来放入方括号中的东西都可以在对象字面量的计算属性名中生效。
## 新方法
从ECMAScript5开始的一个ECMAScript设计目标就是避免创建新的全局函数或在Object.prototype上创建新方法，取而代之的是尽量寻找新方法应该可用的对象。结果就是，Object全局变量在没有其它对象更为合适的情况下获得了许多新增的方法。
### Object.is()方法
当你想在JavaScript中比较两个值的时候，你可能习惯于使用相等符（`==`）或全等符（`===`）。许多开发人员倾向于后者，从而避免比较中的强制类型转换。但是即使是全等符也不是完全的准确。例如+0和-0的值被`===`认为是相等的，即使它们在JavaScript引擎中表示方法不同。同时，`NaN === NaN`返回`false`，导致必须使用`isNaM()`来检测`NaN`属性。
ECMAScript6引入了`Object.is()`方法来弥补全等符的剩余怪异行为。该方法接受两个参数并在两个值相等时返回`true`。这两个值在具有相同类型和相同的值时被认为是相等的。下面有一些例子：
```
console.log(+0 == -0);             // true
console.log(+0 === -0);            // true
console.log(Object.is(+0, -0));    // false

console.log(NaN == NaN);           // false
console.log(NaN === NaN);          // false
console.log(Object.is(NaN, NaN));  // true

console.log(5 == 5);               // true
console.log(5 == "5");             // true
console.log(5 === 5);              // true
console.log(5 === "5");            // false
console.log(Object.is(5, 5));      // true
console.log(Object.is(5, "5"));    // false
```
在大多数情况下，`Object.is()`与`===`符的效果相同。唯一不同在于+0和-0被认为不同且NaN被认为与NaN相同。但是没有必要停止使用等号操作符。选择使用`Object.is()`还是`==`或`===`取决于这些特殊用例如何影响你的代码。
### Object.assign()方法
*混入（mixins）*为JavaScript对象组合中最流行的模式之一。在混入中，一个对象接收另一个对象的属性和方法。许多JavaScript库都有一个类似如下的混入函数：
```
function mixin(receiver, supplier) {
  Object.keys(supplier).forEach(function(key)) {
    receiver[key] = supplier[key];
  };

  return receiver;
}
```
`mixin()`方法迭代`supplier`自身属性并将它们拷贝到`receiver`中（浅拷贝，如果属性值为对象时共享一个对象引用）。这使得`receiver`无需继承即可获取新的属性，如下面代码所示：
```
function EventTarget() { /**...*/ }
EventTarget.prototype = {
  constructor: EventTarget,
  emit: function() { /**...*/ },
  on: function() { /**...*/ }
};

var myObject = {};
mixin(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
```
此处，`myObject`从`EventTarget.prototype`对象中接收行为。这赋予`myObject`使用`emit()`和`on()`分别发布和订阅事件的能力。
这种模式是如此的流行以致于ECMAScript6中新增了`Object.assign()`方法，它与该模式行为相同，接受一个接收对象和许多提供对象，并返回接收对象。`mixin()`到`assign()`的命名变化反映了实际执行的操作。由于`mixin()`函数使用赋值操作符（`=`），它无法将访问器属性赋给接收对象作为访问器属性。`Object.assign()`的名字被选来反映这种区别。
## 对象字面量属性复制
## 自有属性枚举顺序
## 更强大的原型
### 改变对象原型
### 使用super引用轻松访问原型
## 正式的方法定义
## 总结
