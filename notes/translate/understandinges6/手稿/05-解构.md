# 轻松访问数据的解构
对象和数组字面量是JavaScript种最用的两种表示方法，而由于JSON数据格式的流行，它们在这个语言种成为尤为重要的一部分。定义对象和数组，然后从这些数据结构中系统地提取相关信息片段是非常常见的。ECMAScript 6通过新增*解构(destrcuturing)*来简化这个任务，它将一个数据结构分解为更小的部分。本章介绍如何在对象和数组中使用解构。
## 为什么要解构
在ECMAScript 5及之前，从对象和数组中获取数据可能会导致许多看起来相同的代码，而只是为了获取特定数据到本地变量中。例如：
```
let options = {
  repeat: true,
  save: false
};

// 从对象中获取数据
let repeat = options.repeat,
    save = options.save;
```
这段代码从`options`对象中获取`repeat`和`save`的值，并将数据存储在同名的本地变量中。虽然这段代码看起来很简单，但是想象一如果你有许多变量需要赋值，你可能需要一个个来为它们赋值。而且如果有一个需要通过遍历来获取信息的嵌套数据结构，那么你可能需要深层遍历整个结构来获取一小段信息。
这就是为什么ECMAScript 6为对象和数组新增了结构。当你分解一个数据结构为更小的部分时，可以更轻易地获取你想要的信息。许多语言通过最少语句实现了解构，来使该过程更易于使用。ECMAScript 6实现实际上是使用了你早已熟悉的语法：对象和数组字面量语法。
## 对象解构
对象解构语法在一个赋值操作中将对象字面量作为左值。例如：
```
let node = {
  type: "Identifier",
  name: "foo"
};

let { type, name } = node;
console.log(type);  // "Identifier"
console.log(name);  // "foo"
```
在该代码中，`node.type`的值被存在名为`type`的变量中，`node.name`的值被存在名为`name`的变量中。该语法和第4章中介绍的对象字面量属性快捷初始化相同。标识符`type`和`name`都是在本地变量中声明的，而属性的值是从`node`对象中读取的。
### 不要忘记初始化
当用解构来声明`var`，`let`或`const`是变量时，你必须提供一个初始化值（等号后的值）。下面的代码中，由于缺失初始化值而都将抛出语法错误：
```
// 语法错误
var  { type, name };

// 语法错误
let  { type, name };

// 语法错误
const  { type, name };
```
虽然即使并非使用在解构变量中，`const`也总是要求初始化，`var`和`let`是只在使用解构时需要初始化。
### 解构赋值
目前为止的对象解构例子中使用了变量声明。然而，在赋值语句中也可以使用解构。例如：你想要在变量定义后改变它们的值，如下：
```
let node = {
      type: "Identifier",
      name: "foo"
    },
    type = "Literal",
    name = 5;

// 使用解构来赋不同的值
({ type, name } = node);

console.log(type);  "Identifier"
console.log(name);  "foo"
```
在这个例子中，`type`和`name`被声明时的值初始化，接着同名的两个变量被不同值初始化。下一行使用解构赋值从`node`对象中读取值来改变这些值。注意你必须在解构赋值语句周围加上括号。这是因为一个开的弯括号被认为是一个块语句，而块语句不能出现在赋值语句的左边。括号表示接下来的弯括号不是一个块语句，而应该被解释为一个表达式，使得该赋值得以完成。
一个解构赋值表达式等于表达式的右边（=之后）。这表明你可以在任何需要值的地方使用解构赋值表达式。例如：为函数传值：
```
let node = {
      type: "Identifier",
      name: "foo"
    },
    type = "Literal",
    name = 5;

function outputInfo(value) {
  console.log(value === node);
}

outputInfo({ type, name } = node);   // true

console.log(type);  // "Identifier"
console.log(name);  // "foo"
```
该`outputInfo()`函数在一个解构赋值表达式上调用。该表达式等于`node`，因为它是表达式右边的值。`type`和`name`正常赋值，`node`被传递给`outputInfo()`。
当解构赋值表达式右边（=之后的表达式）等于`null`或者`undefine`d时将抛出一个错误。这是因为任何试图读取`null`和`undefined`属性的行为将导致一个运行时错误。
