# 使用模块封装代码
JavaScript的“共享一切”载入代码方法是该语言的一个最容易出错和令人迷惑的方面。其它语言使用类似报的概念来定义代码作用域，但在ECMAScript6之前，所有定义在一个应用的每个JavaScript文件中的代码共i昂一个全局作用域。随着网页应用变得越来越复杂，并使用越来越多的JavaScript代码，这种方法导致了命名冲突和安全等问题。ECMAScript6的一个目标就是解决作用域问题并为JavaScript应用提供一些秩序。这就是模块出现的原因。
## 什么是模块
*模块*是通过不同的模式载入的JavaScript文件（不同于*scripts*，它通过JavaScript原始工作方式载入）。必须使用不同的模式是因为模块与脚本有非常不同的语义：
1. 模块代码自动在严格模式下执行，并无法退出严格模式
2. 在模块顶层创建的变量不会被自动添加到共享的全局作用域中。它们只存在在模块的顶层作用域中。
3. 模块顶层的`this`值是`undefined`。
4. 模块不允许代码中有HTML风格的注释（JavaScript的早期浏览器遗留特性）。
5. 模块必须导出可用于模块外部代码的任何内容。
6. 模块可以从其它模块导入引用。
这些不同之处一眼看上去可能很微不足道，但是它们代表了JavaScript代码载入和计算方式的一种重要改变。模块真正的强大之处在于按需导入导出绑定而不是一个文件中的所有内容的能力。对导出和导入的正确理解是理解模块与脚本不同之处的基础。
## 基本导出
你可以使用`export`关键字来向其它模块暴露部分已发布的代码。在最简单的例子中，你可以将`export`放在任何变量、函数或类声明的前面来从模块中导出它，如下：
```js
// 导出数据
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// 导出函数
export function sum(num1, num2) {
  return num1 + num2;
}

// 导出类
export class Rectangle {
  constructor(length, width) {
    this.length = length;
    this.width = width;
  }
}

// 该函数是模块私有的
function subtract(num1, num2) {
  return num1 - num2;
}

// 定义一个函数
function multiply(num1, num2) {
  return num1 * num2;
}

// 稍后导出它
export { multiply }
```
本例中有一些需要关注的地方。首先，除了`export`关键词，每个声明都和它原先一样。每个被导出的函数或类也都有一个名字，这是因为被导出的函数和类声明要求一个名字。你无法通过这个语法导出匿名函数或类，除非你使用`default`关键词（在“模块中的默认值”一节详细讨论）。
接着，考虑`multiply()`函数，它未在定义时被导出。它生效的原因是你无需总是导出一个声明，你也可以导出一个引用。最后，注意到本例没有导出`subtract()`函数。该函数无法在模块外被访问，因为任何未被明确导出的变量、函数或类将保持为模块私有。
## 基本导入
一旦你有了一个具备导出项的的模块，你就可以使用`import`关键词来访问另一个模块中的功能。`import`语句的两个部分分别为你将导入的标识符和这些标识符应该被从哪个模块导入。这是该语句的基本形式：
```js
import { identifier1, identifier2 } from "./example.js"
```
`import`后面的大括号指示了需从给定模块中导入的绑定。关键词`from`指示了从哪个模块导入给定绑定。模块由一个表示该模块路径的字符串指定（模块指示符）。浏览器使用与你可能传给`<script>`元素相同的路径模式，这表明你必须包含一个文件扩展。另一方面，Node.js遵循了传统的基于文件系统前缀的区分本地文件和包的约定。例如，`example`应该是一个包而`./example.js`应该是一个本地文件。
引入的绑定列表看起来类似于一个解构对象，但实际并不是。
当从一个模块中引入一个绑定时，该绑定表现得如同它是用`const`定义的一样。这表明你无法定义一个其它同名的变量（包括引入另一个同名的绑定），在`import`语句前使用该标识符或改变它的值。
### 导入一个单独绑定
假设第一个在“基本导出”一节中的例子是在文件名为`example.js`的模块中。你可以使用多种方法导入和使用该模块中的绑定。例如，你可以只引入一个标识符：
```js
// 只引入一个
import { sum } from "./example.js";

console.log(sum(1, 2));      // 3

sum = 1;     // error
```
虽然`example.js`不止只导出了这个函数，本例只引入了`sum()`函数。如果你试图为`sum`赋一个新值，结果将抛出错误，因为你无法为导入的绑定重新赋值。
确保在要导入的文件开头包含`/`，`./`或者`../`，以获得跨浏览器和Node.js的最佳兼容性。
### 导入多个绑定
如果你想要在例子模块中引入多个绑定，你可以像下面这样明确地列举它们：
```js
// 引入多个
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber));     // 8
console.log(multiply(1, 2));          // 2
```
这里，从例子模块中导入了三个绑定：`sum`，`multiply`和`magicNumber`。接着它们如在本地定义一般被使用。
### 导入一个模块的所有
有一个特殊用例可以允许你将整个模块作为单独对象引入。所有的导出都可以在该对象上作为属性被访问。例如：
```js
import * as example from "./example.js";

console.log(example.sum(1,
        magicNumber));                 // 8
console.log(example.multiply(1, 2));   // 2
```
在这段代码中，`example.js`中所有的导出都被载入到名为`example`的对象中。命名导出（`sum()`函数，`multiply()`函数和`magicNumber`）就在`example`上作为属性可访问。这种导入模式被称为*命名空间导入*，因为`example`对象不存在于`example.js`文件中，而是被用作`example.js`中所有导出成员的一个命名空间对象。
然而，不管你在`import`语句中使用了一个模块多少次，该模块将只被执行一次。当导入该模块的代码执行后，实例化的模块将被保存在内存中并在另一个`import`语句引用它时被重用。考虑下面代码：
```js
import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
```
虽然该模块有三个`import`语句，`example.js`将只被执行一次。如果同一应用中其它模块将从`example.js`中导入模块，这些模块将使用代码中使用同一个模块实例。
### 模块语法限制
`export`和`import`的一个重要限制是它们在其它语句和函数外被使用。例如，下面的代码将抛出一个语法错误：
```js
if (flag) {
  export flag;      // 语法错误
}
```
`export`语句位于`if`语句中，这是不被允许的。导出无法是条件的或者动态的。模块语法存在的一个原因就是使JavaScript引擎可以静态决定哪些将被导出。因此，你可以只在模块的顶层使用`export`。类似地，你无法在一个语句中使用`import`；你只能在顶层使用它。这表明下面的代码也将抛出错误：
```js
function tryImport() {
  import flag from "./example.js";     // 语法错误
}
```
与你无法动态导出绑定的原因相同，你也无法动态导入绑定。`export`和`import`关键词被设计为静态的，因此文本编辑器等工具可以轻易判断一个模块中哪些信息可以被访问。
### 导入绑定的一个微小怪异
ECMAScript6的`import`语句为变量、函数和类创建了一个只读绑定，而不是只简单地如常规变量一样引用原始绑定。虽然引入绑定的模块不会改变它的值，导出该标识符的模块却可以，假设你想要使用下面这个模块：
```js
export var name = "Nicholas";
export function setName(newName) {
  name = newName;
}
```
当你导入这两个绑定时，setName()函数可以改变name的值：
```js
import { name, setName } from "./example.js";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // 抛出错误
```
`setName("Greg")`调用回退入`setName()`被导出的模块并执行，设置`name`为`"Greg"`。注意，这种改变是自动反射到导入的`name`绑定上的。这是因为`name`是导出的`name`标识符的本地名称。代码中使用的`name`和被导入的模块中的`name`并不相同。
## 重命名导出和导入
有时，你可能不想使用你从模块中导入的变量、函数或类的原始名称。幸运的是，你可以在导出和导入时改变一个导出的名称。
在第一个例子中，假设你有一个想用另一个名字导出的函数。你可以使用`as`关键字来指定该函数应该在模块外被获取的名称：
```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as add };
```
这里，`sum()`函数（`sum`为*本地名*）被导出为`add()`（`add`为*导出名*）。这表明当另一个模块想要导入这个函数时，它需要使用`add`作为名称：
```js
import { add } from "./example.js";
```
如果导入函数的模块想要使用一个不同的名称，那么它也可以使用`as`：
```js
import { add as sum } from "./example.js";
console.log(typeof add);              // "undefined"
console.log(sum(1, 2));               // 3
```
该段代码使用*导入名*导入了`add()`函数，并将它重命名为`sum()`（本地名）。这表明模块中不再有名为`add`的标识符。
## 模块中的默认值
模块语法确实优化了从模块中导出和导入默认值，这种模式在其它模块系统中很常见，如CommonJS（因Node.js而流行的另一种JavaScript模块形式）。一个模块的*默认值*为由`default`关键词指定的一个单独变量、函数或类，你只能在一个模块中设置一个默认导出。多个导出使用`default`关键词是一个语法错误。
### 导出默认值
下面有一个使用`default`关键词的简单例子：
```js
export default function(num1, num2) {
  return num1 + num2;
}
```
该模块导出了一个函数作为它的默认值。`default`关键词表明这是一个默认导出。函数不要求一个名字，因为模块自身表示该函数。
你也可以通过在`export default`后放置一个标识符来指定它作为默认导出，例如：
```js
function sum(num1, num2) {
  return num1 + num2;
}

export default sum;
```
此处，`sum()`函数首先被定义并稍后被作为模块的默认值被导出。你可能想选择这种方式，如果默认值需要被计算。
第三中指定标识符为导出默认值的方法是使用如下的重命名语法：
```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as default };
```
标识符`default`在一个重命名导出中有特殊的含义，它指示一个值应该是该模块的默认值。因为`default`是JavaScript中的一个关键词，它无法被作为一个变量、函数或类的名字（它可以被用作属性名）。因此使用`default`来重命名一个导出是一个特殊用例，以创建与非默认导出定义方式的一致性。该语法在你想要用一个单独的`export`语句来一次性指定包含默认值的多个导出时有用。
### 导入默认值
你可以用下面的语法来导入一个模块的默认值：
```js
// 导入默认值
import sum from "./example.js";

console.log(sum(1, 2));     // 3
```
本导入语法从模块`example.js`中导入默认值。注意到不同于在非默认值导入中所见的，此处没有使用大括号。本地名sum被使用来代表任何该模块导出的默认函数。该语法是最简洁的，ECMAScript6的创建人员希望它成为网页导入的主要形式，允许你使用一个早已存在的对象。
对于即导出默认值又导出一个或多个非默认绑定的模块，你可以通过一个语句来导入所有导出的绑定。例如，假设你有以下模块：
```js
export let color = "red";

export default function(num1, num2) {
  return num1 + num2;
}
```
你可以使用下面的`import`语句来同时导入`color`和默认函数：
```js
import sum, { color } from "./example.js";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```
逗号分隔了默认本地名和非默认值，非默认值仍由大括号包围。需要记住的是默认值在`import`语句中必须在非默认值之前。
与导出默认值相同，你也可以使用重命名语法导入默认值：
```js
// 等效于前一个例子
import { default as sum, color } from "example";

console.log(sum(1, 2));     // 3
console.log(color);         // "red"
```
在这段代码中，默认导出（`default`）被重命名为`sum`，额外的`color也`被导出。该例与之前的例子等效。
## 重导出一个绑定
有时你可能想要重导出一个你的模块已导入的内容（例如，如果你正在创建一个多个小模块的库）。你可以使用本章中已讨论过的模式重导出一个引入的值，如下：
```js
import { sum } from "./example.js";
export { sum }
```
它有效，但是一个单独的语句也可以完成相同的事：
```js
export { sum } from "./example.js";
```
这种形式的`export`为`sum`声明寻找指定的模块，接着导出它。当然，你也可以选择为相同值导出为不同名称：
```js
export { sum as add } from "./example.js";
```
此处，`sum`被从`"./example.js"`中导入，并导出为`add`。
如果你想要导出另一个模块中的所有内容，你可以使用*模式：
```js
export * from "./example.js";
```
当你导出所有内容时，你将包含所有命名导出并排除任何默认导出。例如，如果`example.js`有一个默认导出，你需要明确地导入它并明确地导出它。
## 无绑定导入
有些模块可能并不导出任何内容，相反，只修改全局作用域中的对象。虽然模块中的顶层变量、函数和类并不自动终止于全局作用域中，这并不表明模块无法访问全局作用域。内置对象，如`Array`和`Object`的共享定义可以在一个模块中被访问，这些对象的改变将反射到其它模块中。
例如，如果你想为所有数组增加一个`pushAll()`方法，你可能会定义一个像下面一样的模块：
```js
// 无导入导出的模块代码
Array.prototype.pushAll = function(items) {
  
  // items必须是数组
  if (!Array.isArray(items)) {
    throw new TypeError("Arguments must be an array.");
  }

  // 使用内置的push()和扩展操作符
  return this.push(...items)
}
```
这是一个有效的模块，虽然并没有任何导出和导入。改代码既可以被用作模块又可以被用作脚本。因为它不导出任何内容，你可以使用一个简化导入来执行代码，而无需导入任何绑定：
```js
import "./example.js";

let colors = ["red", "green", "blue"];
let items = [];

item.pushAll(colors);
```
该代码导入并执行包含`pushAll()`方法的模块，因此`pushAll()`被添加到数组原型上。这表明`pushAll()`现在可以在该模块的任何数组上使用。
无绑定导入最可能被用来创建polyfills和shims。
## 载入模块
### 在网页浏览器中使用模块
#### 用`<script>`使用模块
#### 网页浏览器中模块载入顺序
#### 网页浏览器中的异步模块载入
#### 作为worker载入模块
### 浏览器模块说明符解析
## 总结