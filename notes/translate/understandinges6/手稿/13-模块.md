# 使用模块封装代码
JavaScript的“共享一切”载入代码方法是该语言的一个最容易出错和令人迷惑的方面。其它语言使用类似报的概念来定义代码作用域，但在ECMAScript6之前，所有定义在一个应用的每个JavaScript文件中的代码共i昂一个全局作用域。随着网页应用变得越来越复杂，并使用越来越多的JavaScript代码，这种方法导致了命名冲突和安全等问题。ECMAScript6的一个目标就是解决作用域问题并为JavaScript应用提供一些秩序。这就是模块出现的原因。
## 什么是模块
*模块*是通过不同的模式载入的JavaScript文件（不同于*scripts*，它通过JavaScript原始工作方式载入）。必须使用不同的模式是因为模块与脚本有非常不同的语义：
1. 模块代码自动在严格模式下执行，并无法退出严格模式
2. 在模块顶层创建的变量不会被自动添加到共享的全局作用域中。它们只存在在模块的顶层作用域中。
3. 模块顶层的`this`值是`undefined`。
4. 模块不允许代码中有HTML风格的注释（JavaScript的早期浏览器遗留特性）。
5. 模块必须导出可用于模块外部代码的任何内容。
6. 模块可以从其它模块导入引用。
这些不同之处一眼看上去可能很微不足道，但是它们代表了JavaScript代码载入和计算方式的一种重要改变。模块真正的强大之处在于按需导入导出绑定而不是一个文件中的所有内容的能力。对导出和导入的正确理解是理解模块与脚本不同之处的基础。
## 基本导出
你可以使用`export`关键字来向其它模块暴露部分已发布的代码。在最简单的例子中，你可以将`export`放在任何变量、函数或类声明的前面来从模块中导出它，如下：
```js
// 导出数据
export var color = "red";
export let name = "Nicholas";
export const magicNumber = 7;

// 导出函数
export function sum(num1, num2) {
  return num1 + num2;
}

// 导出类
export class Rectangle {
  constructor(length, width) {
    this.length = length;
    this.width = width;
  }
}

// 该函数是模块私有的
function subtract(num1, num2) {
  return num1 - num2;
}

// 定义一个函数
function multiply(num1, num2) {
  return num1 * num2;
}

// 稍后导出它
export { multiply }
```
本例中有一些需要关注的地方。首先，除了`export`关键词，每个声明都和它原先一样。每个被导出的函数或类也都有一个名字，这是因为被导出的函数和类声明要求一个名字。你无法通过这个语法导出匿名函数或类，除非你使用`default`关键词（在“模块中的默认值”一节详细讨论）。
接着，考虑`multiply()`函数，它未在定义时被导出。它生效的原因是你无需总是导出一个声明，你也可以导出一个引用。最后，注意到本例没有导出`subtract()`函数。该函数无法在模块外被访问，因为任何未被明确导出的变量、函数或类将保持为模块私有。
## 基本导入
一旦你有了一个具备导出项的的模块，你就可以使用`import`关键词来访问另一个模块中的功能。`import`语句的两个部分分别为你将导入的标识符和这些标识符应该被从哪个模块导入。这是该语句的基本形式：
```js
import { identifier1, identifier2 } from './example.js'
```
`import`后面的中括号指示了需从给定模块中导入的绑定。关键词`from`指示了从哪个模块导入给定绑定。模块由一个表示该模块路径的字符串指定（模块指示符）。浏览器使用与你可能传给`<script>`元素相同的路径模式，这表明你必须包含一个文件扩展。另一方面，Node.js遵循了传统的基于文件系统前缀的区分本地文件和包的约定。例如，`example`应该是一个包而`./example.js`应该是一个本地文件。
引入的绑定列表看起来类似于一个解构对象，但实际并不是。
当从一个模块中引入一个绑定时，该绑定表现得如同它是用`const`定义的一样。这表明你无法定义一个其它同名的变量（包括引入另一个同名的绑定），在`import`语句前使用该标识符或改变它的值。
### 导入一个单独绑定
假设第一个在“基本导出”一节中的例子是在文件名为`example.js`的模块中。你可以使用多种方法导入和使用该模块中的绑定。例如，你可以只引入一个标识符：
```js
// 只引入一个
import { sum } from "./example.js";

console.log(sum(1, 2));      // 3

sum = 1;     // error
```
虽然`example.js`不止只导出了这个函数，本例只引入了`sum()`函数。如果你试图为`sum`赋一个新值，结果将抛出错误，因为你无法为导入的绑定重新赋值。
确保在要导入的文件开头包含`/`，`./`或者`../`，以获得跨浏览器和Node.js的最佳兼容性。
### 导入多个绑定
如果你想要在例子模块中引入多个绑定，你可以像下面这样明确地列举它们：
```js
// 引入多个
import { sum, multiply, magicNumber } from "./example.js";
console.log(sum(1, magicNumber));     // 8
console.log(multiply(1, 2));          // 2
```
这里，从例子模块中导入了三个绑定：`sum`，`multiply`和`magicNumber`。接着它们如在本地定义一般被使用。
### 导入一个模块的所有
有一个特殊用例可以允许你将整个模块作为单独对象引入。所有的导出都可以在该对象上作为属性被访问。例如：
```js
import * as example from './example.js';

console.log(example.sum(1,
        magicNumber));                 // 8
console.log(example.multiply(1, 2));   // 2
```
在这段代码中，`example.js`中所有的导出都被载入到名为`example`的对象中。命名导出（`sum()`函数，`multiply()`函数和`magicNumber`）就在`example`上作为属性可访问。这种导入模式被称为*命名空间导入*，因为`example`对象不存在于`example.js`文件中，而是被用作`example.js`中所有导出成员的一个命名空间对象。
然而，不管你在`import`语句中使用了一个模块多少次，该模块将只被执行一次。当导入该模块的代码执行后，实例化的模块将被保存在内存中并在另一个`import`语句引用它时被重用。考虑下面代码：
```js
import { sum } from "./example.js";
import { multiply } from "./example.js";
import { magicNumber } from "./example.js";
```
虽然该模块有三个`import`语句，`example.js`将只被执行一次。如果同一应用中其它模块将从`example.js`中导入模块，这些模块将使用代码中使用同一个模块实例。
### 模块语法限制
`export`和`import`的一个重要限制是它们在其它语句和函数外被使用。例如，下面的代码将抛出一个语法错误：
```js
if (flag) {
  export flag;      // 语法错误
}
```
`export`语句位于`if`语句中，这是不被允许的。导出无法是条件的或者动态的。模块语法存在的一个原因就是使JavaScript引擎可以静态决定哪些将被导出。因此，你可以只在模块的顶层使用`export`。类似地，你无法在一个语句中使用`import`；你只能在顶层使用它。这表明下面的代码也将抛出错误：
```js
function tryImport() {
  import flag from './example.js';     // 语法错误
}
```
与你无法动态导出绑定的原因相同，你也无法动态导入绑定。`export`和`import`关键词被设计为静态的，因此文本编辑器等工具可以轻易判断一个模块中哪些信息可以被访问。
### 导入绑定的一个微小怪异
ECMAScript6的`import`语句为变量、函数和类创建了一个只读绑定，而不是只简单地如常规变量一样引用原始绑定。虽然引入绑定的模块不会改变它的值，导出该标识符的模块却可以，假设你想要使用下面这个模块：
```js
export var name = "Nicholas";
export function setName(newName) {
  name = newName;
}
```
当你导入这两个绑定时，setName()函数可以改变name的值：
```js
import { name, setName } from "./example.js";

console.log(name);       // "Nicholas"
setName("Greg");
console.log(name);       // "Greg"

name = "Nicholas";       // 抛出错误
```
`setName("Greg")`调用回退入`setName()`被导出的模块并执行，设置`name`为`"Greg"`。注意，这种改变是自动反射到导入的`name`绑定上的。这是因为`name`是导出的`name`标识符的本地名称。代码中使用的`name`和被导入的模块中的`name`并不相同。
## 重命名导出和导入
有时，你可能不想使用你从模块中导入的变量、函数或类的原始名称。幸运的是，你可以在导出和导入时改变一个导出的名称。
在第一个例子中，假设你有一个想用另一个名字导出的函数。你可以使用`as`关键字来指定该函数应该在模块外被获取的名称：
```js
function sum(num1, num2) {
  return num1 + num2;
}

export { sum as add };
```
这里，`sum()`函数（`sum`为*本地名*）被导出为`add()`（`add`为*导出名*）。这表明当另一个模块想要导入这个函数时，它需要使用`add`作为名称：
```js
import { add } from "./example.js";
```
如果导入函数的模块想要使用一个不同的名称，那么它也可以使用`as`：
```js
import { add as sum } from './example.js';
console.log(typeof add);              // "undefined"
console.log(sum(1, 2));               // 3
```
该段代码使用*导入名*导入了`add()`函数，并将它重命名为`sum()`（本地名）。这表明模块中不再有名为`add`的标识符。
## 模块中的默认值
### 导出默认值
### 导入默认值
## 重导出一个绑定
## 无绑定导入
## 载入模块
### 在网页浏览器中使用模块
#### 用`<script>`使用模块
#### 网页浏览器中模块载入顺序
#### 网页浏览器中的异步模块载入
#### 作为worker载入模块
### 浏览器模块说明符解析
## 总结