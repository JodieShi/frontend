# 函数
函数是任一编程语言中重要的一部分，在ECMAScript 6之前，JavaScript函数自该语言创建以来并没有太大改变。这造成了大量遗留的积压问题和细节行为，使得出错变得容易并经常需要更多的代码来实现非常基本的行为。
ECMAScript 6函数有了很大的飞跃，考虑了JavaScript开发者多年以来的抱怨和需求。结果为在ECMAScript 5函数基础上有了许多增量改进，使得JavaScript编程更少出错并更强大。
## 带默认参数值的函数
JavaScript函数是独特的，它允许任意数量的参数被传入，而不管声明函数定义时的参数个数。这使得你能够定义可以处理不同参数数量的函数，一般只需要在参数未提供时填入默认值。本节介绍了在ECMAScript 6及之前是如何使用默认参数的，以及使用参数表达式时`arguments`对象的一些重要信息和另一个TDZ。
### 在ECMAScript 5中模拟默认参数值
在ECMAScript 5及之前，你可能会使用下面的模式来创建一个带默认参数值的函数：
```
function makeRequest(url, timeout, callback) {
  timeout = timeout || 2000;
  callback = callback || function() {};

  // 其它
}
```
在这个例子中，`timeout`和`callback`实际上都是可选的，因为它们在参数未提供时被给予了一个默认值。逻辑OR操作（`||`）在第一个参数为假时总是返回第二个操作数。由于未明确给出的命名函数参数将被设为`undefined`，逻辑或操作经常被用来为缺失的参数提供默认值。然而这个方法有一个缺陷，`timeout`的有效值可能为`0`，但是这时将被`2000`替代，因为`0`是逻辑假值。
这种情况下，更安全的选项是使用`typeof`检查参数的类型，例如在这个例子中：
```
function makeRequest(url, timeout, callback) {
  timeout = (typeof timeout !== "undefined") ? timeout : 2000;
  callback = (typeof callback !== "undefined") ? callback : function() {};

  // 其他
}
```
虽然这种方法更为安全，它仍需要为一个基本操作提供许多额外代码。许多流行的JavaScript库中有许多这种类似的模式，因为它代表了一个常用模式。
### ECMAScript 6默认参数值
ECMAScript6通过为未传入的形参提供初始值来简化为参数提供默认值。例如：
```
function makeRequest(url, timeout = 2000, callback = function() {}) {
  // 其他
}
```
该函数只期望第一个参数永远是会被传入的。其他两个参数具有默认值，使得函数体减短，因为你不需要增加任何代码来检查缺失值。
当`makeRequest()`通过所有三个参数调用时，默认值不会被用上。例如：
```
// 使用默认的timeout和callback
makeRequest("/foo");

// 使用默认的callback
makeRequest("/foo", 500)

// 不使用默认值
makeRequest("/foo", 500, function(body) {
  doSomething(body);
});
```
ECMAScript6认为`url`是必须的，因此三个`makeRequest()`调用中都传入了`"/foo"`。具有默认值的两个参数被认为是可选的。
可以为任意参数指定默认值，包括在函数定义中出现在无默认值参数前的那些。例如，下面的定义是可以的：
```
function makeRequest(url, timeout = 2000, callback) {
  // 其他
}
```
在这个例子中，`timeout`的默认值只在没有第二个参数传入或第二个参数被意外传入`undefined`时才会被使用，如下例所示：
```
// 使用默认timeout
makeRequest("/foo", undefined, function(body) {
  doSomething(body)
});

//使用默认timeout
makeRequest("/foo");

// 不会使用默认timeout
makeRequest("/foo", null, function(body) {
  doSomething(body)
});
```
在使用默认参数值时，`null`值被认为是有效的，即在第三个`makeRequest()`调用中，不会使用`timeout`的默认值。
### 默认参数值对arguments对象的影响
需要记住`arguments`对象的行为在有默认参数值是不同的。在ECMAScript5非严格模式中，`arguments`对象映射函数的命名参数的变化。这里有一些解释它如何工作的代码：
```
function mixArgs(first, second) {
  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
  first = "c";
  second = "d";
  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
}

mixArgs("a", "b");
```
它输出：
```
true
true
true
true
```
`arguments`对象在非严格模式中不断更新来映射命名参数中的变化。因此，当`first`和`second`被赋予新值时，`arguments[0]`和`arguments[1]`相应地被更新，使得`===`比较等于`true`。
然而ECMAScript5的严格模式消除了`arguments`对象的这种迷惑表现。在严格模式中，`arguments`对象不会映射命名参数的变化。这里在严格模式下再次使用`mixArgs()`函数：
```
function mixArgs(first, second) {
  "use strict";

  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
  first = "c";
  second = "d";
  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
}

mixArgs("a", "b");
```
`mixArgs()`函数调用输出：
```
true
true
false
false
```
这次，改变`first`和`second`不会影响`arguments`，因此输出会像你一般认为的那样。
在使用ECMAScript6默认参数值的函数中，`arguments`对象总是像ECMAScript5严格模式中的方式来工作，不管函数是否特别地在严格模式下运行。默认参数值的存在触发了`arguments`对象持续与命名参数分离。这是个微小但很重要的细节，因为`arguments`可能使用的方式。考虑以下：
```
// 非严格模式下
function mixArgs(first, second = "b") {
  console.log(arguments.length);
  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
  first = "c";
  second = "d";
  console.log(first === arguments[0]);
  console.log(second === arguments[1]);
}

mixArgs("a");
```
它输出：
```
1
true
false
false
false
```
在这个例子中，`arguments.length`为1，因为只有一个参数被传递给了`mixArgs`。它也表明`arguments[1]`为`undefined`，这是当只有一个参数传给函数时期望的行为。这表明`first`全等于`arguments[0]`。改变`first`和`second`不会对`arguments`产生影响。这种行为在严格模式和非严格模式中都会发生，因此你可以依赖`arguments`来映射初始调用状态。
### 默认参数表达式
也许默认参数值最有趣的特点在于默认值无需是原始类型值。例如，你可以执行一个函数来获得默认参数值，如下：
```
function getValue() {
  return 5;
}

function add(first, second = getValue()) {
  return first + second;
}

console.log(add(1, 1));  // 2
console.log(add(1));  // 6
```
这里，如果最后一个参数没有被提供，将执行函数getValue()来获取正确的默认值。记住`getValue()`只有当`add()`在无第二个参数的情况下被调用时才会被调用，而不是在函数定义被第一次解析时。这表明如果`getValue()`如果用不同的方法来写，那它可能会返回不同值。例如：
```
let value = 5;
function getValue() {
  return value++;
}

function add(first, second = getValue()) {
  return first + second;
}

console.log(add(1, 1));  // 2
console.log(add(1));  // 6
console.log(add(1));  // 7
```
在这个例子中，`value`开始等于5，每次调用`getValue()`时递增。第一次`add(1)`调用返回6，而第二次`add(1)`返回7，因为`value`递增了。因为`second`只在函数被调用时计算，因此该值的变化可能发生在任何时候。
使用函数调用作为参数值的时候需要小心。如果你忘记了括号，如在上例中`second = getValue`，那么你传递了一个该函数的引用而不是函数调用的结果。
该行为引入了另一种有趣的能力。你可以使用前继参数作为后续参数的默认值。这里有个例子：
```
function add(first, second = first) {
  return first + second;
}

console.log(add(1, 1));  //2
console.log(add(1));  // 2
```
在该代码中，参数`second`被赋予`first`作为默认值，说明只传入一个参数会使得两个参数具有相同的值。因此，`add(1, 1)`与`add(1)`同样都返回2。更进一步，你可以传递`first`给一个获取`second`值的函数，如下：
```
function getValue(value) {
  return value + 5;
}

function add(first, second = getValue(first)) {
  return first + second;
}

console.log(add(1, 1));  // 2
console.log(add(1));  // 7
```
该例子设`second`为`getValue(first)`的返回值，因此`add(1, 1)`依旧返回2，而`add(1)`返回7（1 + 6）。
从默认参数赋值中引用参数的能力只在前继参数中有效，所以前面的参数无法访问后面的参数。例如：
```
function add(first = second, second) {
  return first + second;
}

console.log(add(1, 1));  // 2
console.log(add(undefined, 1));  // 抛出错误
```
`add(undefined, 1)`调用将抛出一个错误，因为`second`是在`first`之后定义的，因此无法作为默认值。为了理解为什么它会发生，需要复习一下暂时性死区。
### 默认参数值暂时性死区
第一章中因为与`let`和`const`相关而介绍了暂时性死区(TDZ)，默认参数值也有一个暂时无法访问参数的TDZ。类似于`let`声明，每个参数都创建了一个新的标识符绑定，在不抛出错误的情况下无法在它初始化之前引用它。参数初始化在函数被调用的时候发生，或者通过为参数传递一个值，或者使用默认参数值。
为了研究默认参数值TDZ，再次考虑以下默认参数表达式一节中的例子：
```
function getValue(value) {
  return value + 5;
}

function add(first, second = getValue(first)) {
  return first + second;
}

console.log(add(1, 1));  // 2
console.log(add(1));  // 7
```
## 使用未命名参数
### ECMAScript 5中的未命名参数
### 剩余参数
#### 剩余参数限制
#### 剩余参数对参数对象的影响
## 构造函数的增强功能
## 展开操作符
## ECMAScript 6的name属性
### 选择合适的name
### name属性的特殊用例
## 阐明函数的双重作用
### ECMAScript 5中确定函数是如何调用的
### new.target元属性
## 块级函数
### 决定何时使用块级函数
### 非严格模式下的块级函数
## 箭头函数
### 箭头函数语法
### 创建立即调用函数表达式
### 无this绑定
### 箭头函数和数组
### 无参数绑定
### 识别箭头函数
## 尾调用优化
### 有什么区别
### 如何使用尾调用优化
## 总结
