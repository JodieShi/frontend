# 代理和反射API
ECMAScript5和ECMAScript6的发展都考虑到了解开JavaScript功能的神秘面纱。例如，JavaScript环境在ECMAScript5之前包含了不可枚举和不可写对象属性，但是开发人员无法定义自己的不可枚举或不可写属性。ECMAScript5包含了`Object.defineProperty()`方法来使得开发者完成JavaScript引擎早已可以做的事。
ECMAScript6给了开发者可以进一步访问以前仅适用于内置对象的JavaScript引擎能力。该语言通过*代理（proxies）*暴露了对象的内部工作方式，代理是可以拦截和更改JavaScript引擎底层操作的包装器。本章从详细介绍代理着力解决的问题开始，接着讨论你如何才能高效创建和使用代理。
## 数组问题
在ECMAScript6之前，JavaScript数组对象以开发人员无法通过自己的对象模拟的方式工作。一个数组的`length`属性在你复制给特定数组元素时发生变化，你也可以通过改变`length`属性来改变数组元素项。例如：
```js
let colors = ["red", "green", "blue"];

console.log(colors.length);     // 3

colors[3] = "black";

console.log(colors.length);     // 4
console.log(colors[3]);         // "black"

colors.length = 2;

console.log(colors.length);     // 2
console.log(colors[3]);         // undefined
console.log(colors[2]);         // undefined
console.log(colors[1]);         // "green"
```
`colors`数组开始有三项。将`"black"`赋给`colors[3]`自动将`length`属性增加到`4`。将`length`属性设为`2`移除了数组中的最后两项，只留下最开始的两项。ECMAScript5中没有允许开发者实现这种行为的方法，但是代理改变了它。
这种非标准行为就是数组在ECMAScript6中被视为怪异对象的原因。
## 什么是代理和反射
你可以通过调用`new Proxy()`创建一个代理来替代另外一个对象（被称为*目标（target）*）使用。代理*虚拟化*了目标，因此代理和目标在使用代理功能上看起来是相同的对象。
代理允许你拦截目标上的底层对象操作，否则这些操作将是JavaScript引擎内部的。这些底层操作通过一个*陷阱（trap）*拦截，一个陷阱是对应于一个特定操作的函数。
由`Reflect`对象表示的反射API是一个方法集合，这些方法为代理可重写的相同底层操作提供默认行为。每个代理陷阱都有一个`Reflect`方法。这些方法与对应代理陷阱有相同的名称并传入相同的参数。表11-1总结了这些行为：
|代理陷阱|重写的行为|默认行为|
|----------------------------|----------------------------|---------------------|
|`get`                       |读取一个属性值              |`Reflect.get()`      |
|`set`                       |写一个属性                  |`Reflect.set()`      |
|`has`                       |`in`操作符                  |`Reflect.has()`      |
|`deleteProperty`            |`delete`操作符              |`Reflect.deleteProperty()`  |
|`getPrototypeOf`            |`Object.getPrototypeOf()`   |`Reflect.getPrototypeOf()`  |
|`setPrototypeOf`            |`Object.setPrototypeOf()`   |`Reflect.setPrototypeOf()`  |
|`isExtensible`              |`Object.isExtensible()`     |`Reflect.isExtensible()`    |
|`preventExtensions`         |`Object.preventExtensions()`  |`Reflect.preventExtensions()` |
|`getOwnPropertyDescriptor`  |`Object.getOwnPropertyDescriptor()` |`Reflect.getOwnPropertyDescriptor()` |
|`defineProperty`            |`Object.defineProperty()`   |`Reflect.defineProperty()`  |
|`ownKeys`                   |`Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`  |`Reflect.ownKeys()`    |
|`apply`                     |调用一个函数                |`Reflect.apply()`     |
|`construct`                 |使用`new`调用一个函数         |`Reflect.construct()` |
每个陷阱都重写了JavaScript对象的一些内置行为，允许你拦截并修改这些行为。如果你仍需使用这些内置行为，那么你可以使用对应的反射API方法。代理和反射API的关系当你开始创建代理时变得清晰，因此最好开始看一些例子。
初始的ECMAScript6标准有一个额外的`enumerate`陷阱，它被设计来替代`for-in`和`Object.keys()`是如何枚举对象上的属性的。然而，`enumerate`陷阱在ECMAScript7（也被称为ECMAScript 2016）中因为实现过程中发现的困难而被移除。`enumerate`陷阱不再存在于任何JavaScript环境中，因此并没有包含在本章中。
## 创建一个简单代理
当你使用`Proxy`构造函数创建一个代理时，你需要向它传两个参数：目标和处理器。一个*处理器*时一个定义了一个或多个陷阱的对象。代理为所有的操作使用默认行为，除非为该操作定义了陷阱。为了创建一个简单的转发代理，你可以使用一个没有任何陷阱的处理器：
```js
let target = {};

let proxy = new Proxy(target, {});

proxy.name = "proxy";
console.log(proxy.name);           // "proxy"
console.log(target.name);          // "proxy"

target.name = "target";
console.log(proxy.name);           // "target"
console.log(target.name);          // "target"
```
在这个例子中，`proxy`直接向`target`转发了所有操作。当`"proxy"`被赋值给`proxy.name`属性时，`name`被创建在`target`上。代理自身并不存储这个属性，它只是简单的向`target`转发这个操作。类似地，`proxy.name`和`target.name`是相同的，因为它们都引用自`target.name`。这同时表示给`target.name`设置新值将导致`proxy.name`反射出相同的改变。当然，没有任何陷阱的代理并不十分吸引人，那么当你定义了一个陷阱时将会发生什么？
## 使用`set`陷阱验证属性
假设你想创建一个属性值必需为数字的对象。这表明添加到该对象上的每个新属性都必需被验证，如果值不是一个数字那么必需抛出一个错误。为了实现它，你可以定义一个重写设置值行为的`set`陷阱。这个`set`陷阱接收四个参数：
1. `trapTarget` - 将接收该属性的对象（代理的目标）
2. `key` - 将写入的属性键（字符串或者symbol）
3. `value` - 将写入该属性的值
4. `receiver` - 操作将发生的对象（通常为代理）

`Reflect.set()`是`set`陷阱对应的反射方法，也是该操作的默认行为。`Reflect.set()`方法接收与`set`代理陷阱相同的四个参数，使该方法在陷阱内易于使用。该陷阱在属性被设置时返回`true`，否则返回`false`。（`Reflect.set()`方法根据操作是否成功返回正确的值。）
为了验证属性的值，你可以使用`set`陷阱检查传入的`value`。这里有一个例子：
```js
let target = {
  name: "target"
};

let proxy = new Proxy(target, {
  set(trapTarget, key, value, receiver) {

    // 忽略已有的属性从而不影响到它们
    if (!trapTarget.hasOwnProperty(key)) {
      if (isNaN(value)) {
        throw new TypeError("Property must be a number.")
      }
    }

    // 新增属性
    return Reflect.set(trapTarget, key, value, receiver);
  }
});

// 增加一个新的属性
proxy.count = 1
console.log(proxy.count);       // 1
console.log(target.count);      // 1

// 你可以赋值给name，因为它已经存在于目标上
proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);        // "proxy"

// 抛出一个错误
proxy.anotherName = "proxy";
```
这段代码定义了一个代理陷阱，它验证任何新增到`target`上的属性值。当`proxy.count = 1`被执行时，`set`陷阱被调用。`trapTarget`值等于`target`，`key`是`"count"`，`value`是`1`，`receiver`（本例中并没有被使用）是`proxy`。`target`上并不存在名为`count`的属性，因此代理将通过把`value`传给`isNaN()`来验证它。如果结果是`NaN`，那么属性值不是数值，将抛出一个错误。由于代码将`count`设为`1`，代理使用与传给陷阱相同的四个参数调用`Reflect.set()`来添加新的属性。
当赋一个字符串给`proxy.name`时，操作成功完成。因为`target`已经有一个`name`属性，该属性在调用`trapTarget.hasOwnProperty()`方法时避免了有效性检查。这确保了已存在的非数值属性依旧被支持。
然而当赋一个字符串给`proxy.anotherName`时将抛出一个错误。`anotherName`属性并不存在于目标上，因此该值需要被验证。在验证时，由于`"proxy"`不是一个数值而抛出一个错误。
`set`代理陷阱使得你可以在属性被写入时拦截，`get`代理陷阱使得你可以在属性被读取时拦截。
## 使用`get`陷阱验证对象形状
JavaScript的一个最有意思，有时也很迷惑人的方面在于读取一个不存在的属性并不抛出一个错误。反而，值undefined将作为它的属性值，如下例所示：
```js
let target = {};

console.log(target.name);       // undefined
```
在其它多数语言中，试图读取`target.name`将抛出一个错误，因为该值并不存在。但是JavaScript只是使用`undefined`来表示`target.name`属性的值。如果你曾经处理过大型代码库，那么你可能已经见过这种行为将导致多少问题，尤其是当属性名拼写错误时。代理可以通过对象形状验证来使你避免这些问题。
一个*对象形状*是对象上可访问属性和方法的集合。JavaScript引擎使用对象形状来优化代码，通常创建类来表示对象。如果你可以安全地假设一个对象将总是具备某些相同的属性以及它开始时具有的方法（一种可以使用`Object.preventExtensions()`, `Object.seal()`或`Object.freeze()`方法强制执行的行为），那么在试图访问不存在的属性时抛出一个错误将很有用。代理使得对象形状验证更简单。
由于属性验证只在该属性被读取的时候发生，你可以使用`get`陷阱。`get`陷阱在一个属性被读取时调用，即使该属性不存在于对象上，它有三个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要读取的属性键（一个字符串或者一个symbol）
3. `receiver` - 操作发生的对象（通常是代理）

这些参数与`set`陷阱参数相同，但有一个明显的不同。由于`get`陷阱并不写入值，此处没有`value`参数。`Reflect.get()`方法接收与`get`陷阱相同的三个参数并返回属性的默认值。
你可以使用`get`陷阱和`Reflect.get()`来当一个属性不存在于目标上时抛出一个错误，如下：
```js
let proxy = new Proxy({}, {
  get(trapTarget, key, receiver) {
    if (!(key in receiver)) {{
      throw new TypeError("Property " + key + " doesn't exist.");
    }}

    return Reflect.get(trapTarget, key, receiver);
  }
});

// 添加一个属性时正常工作
proxy.name = "proxy";
console.log(proxy.name);      // "proxy"

// 访问不存在的属性时将抛出一个错误
console.log(proxy.nme);       // 抛出一个错误
```
在这个例子中，`get`陷阱拦截属性读取操作。`in`操作被用来判断属性是否已经存在于`receiver`上。`receiver`与`in`一起使用，而非`trapTarget`，以防`receiver`是一个有`has`陷阱的代理，这将在下一节中讨论。在此例下使用`trapTarget`将避免`has`陷阱从而坑你导致错误的结果。如果属性不存在，那么将抛出一个错误，否则将使用默认行为。
这段代码允许添加`proxy.name`等新属性，并正常写入或读取。最后一行包含了一个拼写错误：`proxy.nme`应该是`proxy.name`。这将抛出一个错误，因为`nme`不作为一个属性存在。
## 使用`has`陷阱隐藏属性的存在
`in`操作符决定了一个属性是否存在于给定对象上并在已有一个自有属性或原型属性匹配属性名或symbol时返回`true`。例如：
```js
let target = {
  value: 42
};

console.log("value" in target);          // true
console.log("toString" in target);       // true
```
`value`和`toString`都存在于`object`上，因此两个`in`操作符例子都返回`true`。`value`属性是一个自有属性而`toString`是一个原型属性（从`Object`继承）。代理可以允许你使用`has`陷阱拦截此行为并为`in`返回不同值。
`has`陷阱在使用`in`操作符时被调用。当被调用时，`has`陷阱被传入了两个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要检查的属性值（字符串或者symbol）

`Reflect.has()`方法接受相同的参数并返回`in`操作符的默认响应。使用`has`陷阱和`Reflect.has()`允许替换一些属性的`in`行为，而为其它的使用默认行为。例如，假设你想要隐藏`value`属性。你可以如下实现：
```js
let target = {
  name: "target",
  value: 42
};


let proxy = new Proxy(target, {
  has(trapTarget, key) {

    if (key === 'value') {
      return false;
    } else {
      return Reflect.has(trapTarget, key);
    }
  }
});

console.log("value" in proxy);          // false
console.log("name" in proxy);           // true
console.log("toString" in proxy);       // true
```
`proxy`的`has`陷阱检查`key`是否为`"value"`，并在是的时候返回`false`。否则，通过调用`Reflect.has()`方法来执行默认行为。最终，`in`操作符在检查`value`属性时返回`false`，虽然`value`确实存在于目标上。其它的属性，`name`和`toString`，正确地在`in`操作符时返回`true`。
## 使用`deleteProperty`陷阱避免属性删除
`delete`操作符移除对象上的一个属性并在成功时返回`true`，失败时返回`false`。在严格模式下，`delete`在你试图删除一个非可配置属性时将抛出一个错误，在非严格模式下，`delete`简单返回`false`。下面为一个例子：
```js
let target = {
  name: "target",
  value: 42
};

Object.defineProperty(target, "name", { configurable: false });

console.log("value" in target);        // true

let result1 = delete target.value;
console.log(result1);                  // true

console.log("value" in target);        // false

// 注意：下面的代码行将在严格模式下抛出一个错误
let result2 = delete target.name;
console.log(result2);                  // false

console.log("name" in target);         // true
```
`value`属性被`delete`操作符删除，因此`in`操作符在第三个`console.log()`调用中返回`false`。不可配置属性`name`无法被删除，因此`delete`操作符简单返回`false`（如果代码在严格模式下运行，将抛出一个错误）。你可以通过在代理中使用`deleteProperty`陷阱来替代这种行为。
`deleteProperty`陷阱在对象属性上使用`delete`操作符时被调用。该陷阱被传入两个参数：
1. `trapTarget` - 要删除属性的对象（代理的目标）
2. `key` - 要删除的属性键（字符串或者symbol）

`Reflect.deleteProperty()`方法提供了`deleteProperty`陷阱的默认实现，并接受相同的两个参数。你可以组合使用`Reflect.deleteProperty()`和`deleteProperty`陷阱来改变`delete`操作符的行为。例如，你可以确保`value`属性不可被删除：
```js
let target = {
   name: "target",
   value: 42
};

let proxy = new Proxy(target, {
  deleteProperty(trapTarget, key) {

    if (key === "value") {
      return false;
    } else {
      return Reflect.deleteProperty(trapTarget, key);
    }
  }
});

// 试图删除proxy.value

console.log("value" in proxy);        // true

let result1 = delete proxy.value;
console.log(result1);                // false

console.log("value" in proxy);       // true

// 试图删除proxy.name
console.log("name" in proxy);        // true
let result2 = delete proxy.name;
console.log(result2);                // true

console.log("name" in proxy);        // false
```
该代码与`has`陷阱一例十分相似，`deleteProperty`陷阱检查`key`是否是`"value"`，是的时候返回`false`。否则，调用`Reflect.deleteProperty()`方法执行默认行为。`value`属性无法通过`proxy`删除，因为该操作被拦截，但`name`属性可以按预想的被删除。该方法在你想要在严格模式下保护某些属性不被删除而不抛出错误时非常有用。
## 原型代理陷阱
第四章介绍了`Object.setPrototypeOf()`方法，它是ECMAScript6中新增的ECMAScript5`Object.getPrototypeOf()`方法的补充。代理允许你通过`setPrototypeOf`和`getPrototypeOf`陷阱来拦截它们的执行。在这两种情况下，Object的方法调用代理上对应名称的陷阱，允许你替换方法的行为。
由于有两个关于原型代理的陷阱，因此每个类型的陷阱都有一组对应的方法。`setPrototypeOf`陷阱接受以下参数：
1. `trapTarget` - 需要设置原型的对象（代理的目标）
2. `proto` - 用作原型的对象

相同的参数将传递给`Object.setPrototypeOf()`和`Reflect.setPrototypeOf()`方法。此外，`getPrototypeOf`陷阱只接受`trapTarget`参数，它也将作为参数传给`Object.getPrototypeOf()`和`Reflect.getPrototypeOf()`方法。
### 原型代理陷阱如何工作
### 为什么有两套方法？
## 对象扩展陷阱
### 两个基础例子
### 复制扩展性方法
## 属性描述符陷阱
### 阻塞Object.defineProperty()
### 描述符对象限制
### 复制描述符方法
#### defineProperty()方法
#### getOwnPropertyDescriptor()方法
## `ownKeys`陷阱
## 使用`apply`和`construct`陷阱的函数代理
### 函数参数校验
### 不使用new调用构造函数
### 覆盖抽象基类构造函数
### 可调用类构造函数
## 可撤销代理
## 解决数组问题
### 检测数组索引
### 当新增元素时增加长度
### 减少长度时删除元素
### 实现MyArray类
## 将代理作为原型
### 在原型上使用`get`陷阱
### 在原型上使用`set`陷阱
### 在原型上使用`has`陷阱
### 作为类原型的代理
## 总结