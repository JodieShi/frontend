# 代理和反射API
ECMAScript5和ECMAScript6的发展都考虑到了解开JavaScript功能的神秘面纱。例如，JavaScript环境在ECMAScript5之前包含了不可枚举和不可写对象属性，但是开发人员无法定义自己的不可枚举或不可写属性。ECMAScript5包含了`Object.defineProperty()`方法来使得开发者完成JavaScript引擎早已可以做的事。
ECMAScript6给了开发者可以进一步访问以前仅适用于内置对象的JavaScript引擎能力。该语言通过*代理（proxies）*暴露了对象的内部工作方式，代理是可以拦截和更改JavaScript引擎底层操作的包装器。本章从详细介绍代理着力解决的问题开始，接着讨论你如何才能高效创建和使用代理。
## 数组问题
在ECMAScript6之前，JavaScript数组对象以开发人员无法通过自己的对象模拟的方式工作。一个数组的`length`属性在你复制给特定数组元素时发生变化，你也可以通过改变`length`属性来改变数组元素项。例如：
```js
let colors = ["red", "green", "blue"];

console.log(colors.length);     // 3

colors[3] = "black";

console.log(colors.length);     // 4
console.log(colors[3]);         // "black"

colors.length = 2;

console.log(colors.length);     // 2
console.log(colors[3]);         // undefined
console.log(colors[2]);         // undefined
console.log(colors[1]);         // "green"
```
`colors`数组开始有三项。将`"black"`赋给`colors[3]`自动将`length`属性增加到`4`。将`length`属性设为`2`移除了数组中的最后两项，只留下最开始的两项。ECMAScript5中没有允许开发者实现这种行为的方法，但是代理改变了它。
这种非标准行为就是数组在ECMAScript6中被视为怪异对象的原因。
## 什么是代理和反射
你可以通过调用`new Proxy()`创建一个代理来替代另外一个对象（被称为*目标（target）*）使用。代理*虚拟化*了目标，因此代理和目标在使用代理功能上看起来是相同的对象。
代理允许你拦截目标上的底层对象操作，否则这些操作将是JavaScript引擎内部的。这些底层操作通过一个*陷阱（trap）*拦截，一个陷阱是对应于一个特定操作的函数。
由`Reflect`对象表示的反射API是一个方法集合，这些方法为代理可重写的相同底层操作提供默认行为。每个代理陷阱都有一个`Reflect`方法。这些方法与对应代理陷阱有相同的名称并传入相同的参数。表11-1总结了这些行为：
|代理陷阱|重写的行为|默认行为|
|----------------------------|----------------------------|---------------------|
|`get`                       |读取一个属性值              |`Reflect.get()`      |
|`set`                       |写一个属性                  |`Reflect.set()`      |
|`has`                       |`in`操作符                  |`Reflect.has()`      |
|`deleteProperty`            |`delete`操作符              |`Reflect.deleteProperty()`  |
|`getPrototypeOf`            |`Object.getPrototypeOf()`   |`Reflect.getPrototypeOf()`  |
|`setPrototypeOf`            |`Object.setPrototypeOf()`   |`Reflect.setPrototypeOf()`  |
|`isExtensible`              |`Object.isExtensible()`     |`Reflect.isExtensible()`    |
|`preventExtensions`         |`Object.preventExtensions()`  |`Reflect.preventExtensions()` |
|`getOwnPropertyDescriptor`  |`Object.getOwnPropertyDescriptor()` |`Reflect.getOwnPropertyDescriptor()` |
|`defineProperty`            |`Object.defineProperty()`   |`Reflect.defineProperty()`  |
|`ownKeys`                   |`Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`  |`Reflect.ownKeys()`    |
|`apply`                     |调用一个函数                |`Reflect.apply()`     |
|`construct`                 |使用`new`调用一个函数         |`Reflect.construct()` |
每个陷阱都重写了JavaScript对象的一些内置行为，允许你拦截并修改这些行为。如果你仍需使用这些内置行为，那么你可以使用对应的反射API方法。代理和反射API的关系当你开始创建代理时变得清晰，因此最好开始看一些例子。
初始的ECMAScript6标准有一个额外的`enumerate`陷阱，它被设计来替代`for-in`和`Object.keys()`是如何枚举对象上的属性的。然而，`enumerate`陷阱在ECMAScript7（也被称为ECMAScript 2016）中因为实现过程中发现的困难而被移除。`enumerate`陷阱不再存在于任何JavaScript环境中，因此并没有包含在本章中。
## 创建一个简单代理
当你使用`Proxy`构造函数创建一个代理时，你需要向它传两个参数：目标和处理器。一个*处理器*时一个定义了一个或多个陷阱的对象。代理为所有的操作使用默认行为，除非为该操作定义了陷阱。为了创建一个简单的转发代理，你可以使用一个没有任何陷阱的处理器：
```js
let target = {};

let proxy = new Proxy(target, {});

proxy.name = "proxy";
console.log(proxy.name);           // "proxy"
console.log(target.name);          // "proxy"

target.name = "target";
console.log(proxy.name);           // "target"
console.log(target.name);          // "target"
```
在这个例子中，`proxy`直接向`target`转发了所有操作。当`"proxy"`被赋值给`proxy.name`属性时，`name`被创建在`target`上。代理自身并不存储这个属性，它只是简单的向`target`转发这个操作。类似地，`proxy.name`和`target.name`是相同的，因为它们都引用自`target.name`。这同时表示给`target.name`设置新值将导致`proxy.name`反射出相同的改变。当然，没有任何陷阱的代理并不十分吸引人，那么当你定义了一个陷阱时将会发生什么？
## 使用`set`陷阱验证属性
假设你想创建一个属性值必需为数字的对象。这表明添加到该对象上的每个新属性都必需被验证，如果值不是一个数字那么必需抛出一个错误。为了实现它，你可以定义一个重写设置值行为的`set`陷阱。这个`set`陷阱接收四个参数：
1. `trapTarget` - 将接收该属性的对象（代理的目标）
2. `key` - 将写入的属性键（字符串或者symbol）
3. `value` - 将写入该属性的值
4. `receiver` - 操作将发生的对象（通常为代理）

`Reflect.set()`是`set`陷阱对应的反射方法，也是该操作的默认行为。`Reflect.set()`方法接收与`set`代理陷阱相同的四个参数，使该方法在陷阱内易于使用。该陷阱在属性被设置时返回`true`，否则返回`false`。（`Reflect.set()`方法根据操作是否成功返回正确的值。）
为了验证属性的值，你可以使用`set`陷阱检查传入的`value`。这里有一个例子：
```js
let target = {
  name: "target"
};

let proxy = new Proxy(target, {
  set(trapTarget, key, value, receiver) {

    // 忽略已有的属性从而不影响到它们
    if (!trapTarget.hasOwnProperty(key)) {
      if (isNaN(value)) {
        throw new TypeError("Property must be a number.")
      }
    }

    // 新增属性
    return Reflect.set(trapTarget, key, value, receiver);
  }
});

// 增加一个新的属性
proxy.count = 1
console.log(proxy.count);       // 1
console.log(target.count);      // 1

// 你可以赋值给name，因为它已经存在于目标上
proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);        // "proxy"

// 抛出一个错误
proxy.anotherName = "proxy";
```
这段代码定义了一个代理陷阱，它验证任何新增到`target`上的属性值。当`proxy.count = 1`被执行时，`set`陷阱被调用。`trapTarget`值等于`target`，`key`是`"count"`，`value`是`1`，`receiver`（本例中并没有被使用）是`proxy`。`target`上并不存在名为`count`的属性，因此代理将通过把`value`传给`isNaN()`来验证它。如果结果是`NaN`，那么属性值不是数值，将抛出一个错误。由于代码将`count`设为`1`，代理使用与传给陷阱相同的四个参数调用`Reflect.set()`来添加新的属性。
当赋一个字符串给`proxy.name`时，操作成功完成。因为`target`已经有一个`name`属性，该属性在调用`trapTarget.hasOwnProperty()`方法时避免了有效性检查。这确保了已存在的非数值属性依旧被支持。
然而当赋一个字符串给`proxy.anotherName`时将抛出一个错误。`anotherName`属性并不存在于目标上，因此该值需要被验证。在验证时，由于`"proxy"`不是一个数值而抛出一个错误。
`set`代理陷阱使得你可以在属性被写入时拦截，`get`代理陷阱使得你可以在属性被读取时拦截。
## 使用`get`陷阱验证对象形状
JavaScript的一个最有意思，有时也很迷惑人的方面在于读取一个不存在的属性并不抛出一个错误。反而，值undefined将作为它的属性值，如下例所示：
```js
let target = {};

console.log(target.name);       // undefined
```
在其它多数语言中，试图读取`target.name`将抛出一个错误，因为该值并不存在。但是JavaScript只是使用`undefined`来表示`target.name`属性的值。如果你曾经处理过大型代码库，那么你可能已经见过这种行为将导致多少问题，尤其是当属性名拼写错误时。代理可以通过对象形状验证来使你避免这些问题。
一个*对象形状*是对象上可访问属性和方法的集合。JavaScript引擎使用对象形状来优化代码，通常创建类来表示对象。如果你可以安全地假设一个对象将总是具备某些相同的属性以及它开始时具有的方法（一种可以使用`Object.preventExtensions()`, `Object.seal()`或`Object.freeze()`方法强制执行的行为），那么在试图访问不存在的属性时抛出一个错误将很有用。代理使得对象形状验证更简单。
由于属性验证只在该属性被读取的时候发生，你可以使用`get`陷阱。`get`陷阱在一个属性被读取时调用，即使该属性不存在于对象上，它有三个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要读取的属性键（一个字符串或者一个symbol）
3. `receiver` - 操作发生的对象（通常是代理）

这些参数与`set`陷阱参数相同，但有一个明显的不同。由于`get`陷阱并不写入值，此处没有`value`参数。`Reflect.get()`方法接收与`get`陷阱相同的三个参数并返回属性的默认值。
你可以使用`get`陷阱和`Reflect.get()`来当一个属性不存在于目标上时抛出一个错误，如下：
```js
let proxy = new Proxy({}, {
  get(trapTarget, key, receiver) {
    if (!(key in receiver)) {{
      throw new TypeError("Property " + key + " doesn't exist.");
    }}

    return Reflect.get(trapTarget, key, receiver);
  }
});

// 添加一个属性时正常工作
proxy.name = "proxy";
console.log(proxy.name);      // "proxy"

// 访问不存在的属性时将抛出一个错误
console.log(proxy.nme);       // 抛出一个错误
```
在这个例子中，`get`陷阱拦截属性读取操作。`in`操作被用来判断属性是否已经存在于`receiver`上。`receiver`与`in`一起使用，而非`trapTarget`，以防`receiver`是一个有`has`陷阱的代理，这将在下一节中讨论。在此例下使用`trapTarget`将避免`has`陷阱从而坑你导致错误的结果。如果属性不存在，那么将抛出一个错误，否则将使用默认行为。
这段代码允许添加`proxy.name`等新属性，并正常写入或读取。最后一行包含了一个拼写错误：`proxy.nme`应该是`proxy.name`。这将抛出一个错误，因为`nme`不作为一个属性存在。
## 使用`has`陷阱隐藏属性的存在
`in`操作符决定了一个属性是否存在于给定对象上并在已有一个自有属性或原型属性匹配属性名或symbol时返回`true`。例如：
```js
let target = {
  value: 42
};

console.log("value" in target);          // true
console.log("toString" in target);       // true
```
`value`和`toString`都存在于`object`上，因此两个`in`操作符例子都返回`true`。`value`属性是一个自有属性而`toString`是一个原型属性（从`Object`继承）。代理可以允许你使用`has`陷阱拦截此行为并为`in`返回不同值。
`has`陷阱在使用`in`操作符时被调用。当被调用时，`has`陷阱被传入了两个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要检查的属性值（字符串或者symbol）

`Reflect.has()`方法接受相同的参数并返回`in`操作符的默认响应。使用`has`陷阱和`Reflect.has()`允许替换一些属性的`in`行为，而为其它的使用默认行为。例如，假设你想要隐藏`value`属性。你可以如下实现：
```js
let target = {
  name: "target",
  value: 42
};


let proxy = new Proxy(target, {
  has(trapTarget, key) {

    if (key === 'value') {
      return false;
    } else {
      return Reflect.has(trapTarget, key);
    }
  }
});

console.log("value" in proxy);          // false
console.log("name" in proxy);           // true
console.log("toString" in proxy);       // true
```
`proxy`的`has`陷阱检查`key`是否为`"value"`，并在是的时候返回`false`。否则，通过调用`Reflect.has()`方法来执行默认行为。最终，`in`操作符在检查`value`属性时返回`false`，虽然`value`确实存在于目标上。其它的属性，`name`和`toString`，正确地在`in`操作符时返回`true`。
## 使用`deleteProperty`陷阱避免属性删除
`delete`操作符移除对象上的一个属性并在成功时返回`true`，失败时返回`false`。在严格模式下，`delete`在你试图删除一个非可配置属性时将抛出一个错误，在非严格模式下，`delete`简单返回`false`。下面为一个例子：
```js
let target = {
  name: "target",
  value: 42
};

Object.defineProperty(target, "name", { configurable: false });

console.log("value" in target);        // true

let result1 = delete target.value;
console.log(result1);                  // true

console.log("value" in target);        // false

// 注意：下面的代码行将在严格模式下抛出一个错误
let result2 = delete target.name;
console.log(result2);                  // false

console.log("name" in target);         // true
```
`value`属性被`delete`操作符删除，因此`in`操作符在第三个`console.log()`调用中返回`false`。不可配置属性`name`无法被删除，因此`delete`操作符简单返回`false`（如果代码在严格模式下运行，将抛出一个错误）。你可以通过在代理中使用`deleteProperty`陷阱来替代这种行为。
`deleteProperty`陷阱在对象属性上使用`delete`操作符时被调用。该陷阱被传入两个参数：
1. `trapTarget` - 要删除属性的对象（代理的目标）
2. `key` - 要删除的属性键（字符串或者symbol）

`Reflect.deleteProperty()`方法提供了`deleteProperty`陷阱的默认实现，并接受相同的两个参数。你可以组合使用`Reflect.deleteProperty()`和`deleteProperty`陷阱来改变`delete`操作符的行为。例如，你可以确保`value`属性不可被删除：
```js
let target = {
   name: "target",
   value: 42
};

let proxy = new Proxy(target, {
  deleteProperty(trapTarget, key) {

    if (key === "value") {
      return false;
    } else {
      return Reflect.deleteProperty(trapTarget, key);
    }
  }
});

// 试图删除proxy.value

console.log("value" in proxy);        // true

let result1 = delete proxy.value;
console.log(result1);                // false

console.log("value" in proxy);       // true

// 试图删除proxy.name
console.log("name" in proxy);        // true
let result2 = delete proxy.name;
console.log(result2);                // true

console.log("name" in proxy);        // false
```
该代码与`has`陷阱一例十分相似，`deleteProperty`陷阱检查`key`是否是`"value"`，是的时候返回`false`。否则，调用`Reflect.deleteProperty()`方法执行默认行为。`value`属性无法通过`proxy`删除，因为该操作被拦截，但`name`属性可以按预想的被删除。该方法在你想要在严格模式下保护某些属性不被删除而不抛出错误时非常有用。
## 原型代理陷阱
第四章介绍了`Object.setPrototypeOf()`方法，它是ECMAScript6中新增的ECMAScript5`Object.getPrototypeOf()`方法的补充。代理允许你通过`setPrototypeOf`和`getPrototypeOf`陷阱来拦截它们的执行。在这两种情况下，Object的方法调用代理上对应名称的陷阱，允许你替换方法的行为。
由于有两个关于原型代理的陷阱，因此每个类型的陷阱都有一组对应的方法。`setPrototypeOf`陷阱接受以下参数：
1. `trapTarget` - 需要设置原型的对象（代理的目标）
2. `proto` - 用作原型的对象

相同的参数将传递给`Object.setPrototypeOf()`和`Reflect.setPrototypeOf()`方法。此外，`getPrototypeOf`陷阱只接受`trapTarget`参数，它也将作为参数传给`Object.getPrototypeOf()`和`Reflect.getPrototypeOf()`方法。
### 原型代理陷阱如何工作
这些陷阱有一些限制。首先，`getPrototypeOf`陷阱必须返回一个对象或者`null`，任何其它返回值都将导致一个运行时错误。返回值检查确保`Object.getPrototypeOf()`将总是返回一个预料中的值。类似的的，`setPrototypeOf`陷阱的返回值必须在操作不成功时为`false`。当`setPrototypeOf`返回`false`时，`Object.setPrototypeOf()`抛出一个错误。如果`setPrototypeOf`返回除了`false`的其它值，`Object.setPrototypeOf()`假设操作是成功的。
下面的例子通过总是返回`null`隐藏了代理的原型并不允许原型被改变：
```js
let target = {};
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return null;
  },
  setPrototypeOf(trapTarget, proto) {
    return false;
  }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);       // true
console.log(proxyProto === Object.prototype);        // false
console.log(proxyProto);                             // null

// 成功
Object.setPrototypeOf(target, {});


// 抛出错误
Object.setPrototypeOf(proxy, {});
```
这段代码强调了`target`和`proxy`之间的区别。虽然`Object.getPrototypeOf()`为`target`返回了一个值，但为`proxy`返回了一个`null`，因为`getPrototypeOf`陷阱被调用。类似地，因为`setPrototypeOf`的存在，`Object.setPrototypeOf()`在`target`上成功调用，但在`proxy`上抛出错误。
如果你想要使用这两个陷阱的默认行为，你可以使用Reflect上的对应方法。例如，下面的代码实现了getPrototypeOf和setPrototypeOf陷阱的默认行为：
```js
let target = {};
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return Reflect.getPrototypeOf(trapTarget);
  },
  setPrototypeOf(trapTarget, proto) {
    return Reflect.setPrototypeOf(trapTarget, proto);
  }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);       // true
console.log(proxyProto === Object.prototype);        // true

// 成功
Object.setPrototypeOf(target, {});

// 也成功
Object.setPrototypeOf(proxy, {});
```
在这个例子中，你可以交换使用`target`和`proxy`并获得相同的结果，因为`getPrototypeOf`和`setPrototypeOf`陷阱只是透传并使用默认实现行为。由于一些重要的差别，本例中使用`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`方法而不是`Object`上的同名方法，这非常重要。
### 为什么有两套方法？
`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`使人迷惑之处在于它们看起来与`Object.getPrototypeOf()`和`Object.setPrototypeOf()`方法非常相似。虽然这两组方法执行相似的操作，它们之间有着明显的差异。
最初`Object.getPrototypeOf()`和`Object.setPrototypeOf()`是为了开发人员使用而创建的高级操作。`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`方法是给开发人员访问之前内部的`[[GetPrototypeOf]]`和`[[SetPrototypeOf]]`操作的低级操作。`Reflect.getPrototypeOf()`方法是内部`[[GetPrototypeOf]]`操作（有一些输入校验）的包装器。`Reflect.setPrototypeOf()`方法和`[[SetPrototypeOf]]`有相同的关系。`Object`上对应的方法也调用`[[GetPrototypeOf]]`和`[[SetPrototypeOf]]`，但是在调用前会执行几步并检查返回值来决定后续行为。
`Reflect.getPrototypeOf()`方法在参数不是对象时将抛出一个错误，而`Object.getPrototypeOf()`在执行操作之前首先会将值强制转换为一个对象。如果你错误地传入了一个数值给这两个方法，你将获得不同的结果：
```js
let result1 = Object.getPrototypeOf(1);
console.log(result1 === Number.prototype);    // true

// 抛出错误
Reflect.getPrototypeOf(1);
```
`Object.getPrototypeOf()`方法允许你获取数值`1`的原型，因为它首先将值强制转换为`Number`对象并返回`Number.prototype`。`Reflect.getPrototypeOf()`方法不会强制转换值，因为`1`不是一个对象，它将抛出一个错误。
`Reflect.setPrototypeOf()`方法也和`Object.setPrototypeOf()`方法之间有一些差别。首先，`Reflect.setPrototypeOf()`返回一个指示操作是否成功的布尔值。成功时返回`true`，失败时返回`false`。如果`Object.setPrototypeOf()`失败，它抛出错误。
如“原型代理陷阱如何工作”中第一个例子所示，当`setPrototypeOf`代理陷阱返回`false`时，它导致`Object.setPrototypeOf`抛出一个错误。`Object.setPrototypeOf()`方法返回第一个参数作为它的值，因此并不适合作为`setPrototypeOf`代理陷阱的默认行为实现。下面的代码解释了这些差异：
```js
let target1 = {};
let result1 = Object.setPrototypeOf(target1, {});
console.log(result1 === target1);                 // true

let target2 = {};
let result2 = Reflect.setPrototypeOf(target2, {});
console.log(result2 === target2);                 // false
console.log(result2);                             // true
```
在这个例子中，`Object.setPrototypeOf()`返回`target1`作为它的值，但是`Reflect.setPrototypeOf()`返回`true`。这些细微差别非常重要。你将在`Object`和`Reflect`上看到更多看起来重复的方法，但请总是在代理陷阱内部使用`Reflect`。
当在代理上使用时，这两组方法都将调用`getPrototypeOf`和`setPrototypeOf`代理陷阱。
## 对象扩展陷阱
ECMAScript5通过`Object.preventExtensions()`和`Object.isExtensible()`方法增加了对象扩展性修改，ECMAScript6允许通过`preventExtensions`和`isExtensible`陷阱来拦截这些方法调用底层对象。这两个方法都接收一个名为trapTarget的单独参数，它是方法调用的对象。`isExtensible`陷阱必须返回一个指示该对象是否可扩展的布尔值，而`preventExtensions`陷阱则返回一个指示操作是否成功的布尔值。
也有`Reflect.preventExtensions()`和`Reflect.isExtensible()`方法来实现默认行为。它们都返回布尔值，所以可以直接在对应的陷阱里使用它们。
### 两个基础例子
为了实际查看对象扩展性陷阱，考虑以下代码，它实现了`isExtensible`和`preventExtensions`陷阱的默认行为：
```js
let target = {};
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget);
  },
  preventExtensions(trapTarget) {
    return Reflect.preventExtensions(trapTarget);
  }
});

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));         // false
console.log(Object.isExtensible(proxy));          // false
```
如本例所示，`Object.preventExtensions()`和`Object.isExtensible()`正确地在`proxy`和`target`间传递。你当然也可以改变行为。例如，如果你不想允许`Object.preventExtensions()`在代理上成功执行，你可以从`preventExtensions`陷阱中返回`false`：
```js
let target = {};
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget);
  },
  preventExtensions(trapTarget) {
    return false;
  }
});

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true
```
此处`Object.preventExtensions(proxy)`调用没有生效，因为`preventExtensions`陷阱返回`false`。操作并没有转发给底层`target`，因此`Object.isExtensible()`返回`true`。
### 复制扩展性方法
再次，你可能已经注意到，`Object`和`Reflect`上有重复的方法。在这个例子中，它们更多地是相似。`Object.isExtensible()`和`Reflect.isExtensible()`除了在传入一个非对象值以外很相似。在那种情况下，`Object.isExtensible()`总是返回`false`而`Reflect.isExtensible()`抛出一个错误。下面有一个这种行为的例子：
```js
let result1 = Object.isExtensible(2);
console.log(result1);                // false

// 抛出错误
let result2 = Reflect.isExtensible(2)
```
这种限制和`Object.getPrototypeOf()`和`Reflect.getPrototypeOf()`方法间的差别相似，因为低层功能方法比高层方法有着更严格的错误检测。
`Object.preventExtensions()`和`Reflect.preventExtensions()`方法也很相似。`Object.preventExtensions()`方法总是讲作为参数传入的值返回，即使它不是一个对象。然而`Reflect.preventExtensions()`方法在参数不为对象时抛出一个错误。如果参数是一个对象，那么`Reflect.preventExtensions()`在操作成功时返回`true`，否则返回`false`。例如：
```js
  let result1 = Object.preventExtensions(2);
  console.log(result1);                      // 2


  let target = {};
  let result2 = Reflect.preventExtensions(target);
  console.log(result2);                      // true

  // 抛出错误
  let result3 = Reflect.preventExtensions(2);
```
这里，`Object.preventExtensions()`将`2`作为返回值传递，即使`2`不是一个对象。`Reflect.preventExtensions()`方法当对象传递给它时返回`true`，而当`2`传入时抛出错误。
## 属性描述符陷阱
在JavaScript之前的版本中，没有方法来定义访问器属性、使得属性只读或不可枚举。这些都可以使用`Object.defineProperty()`方法来实现，你可以通过`Object.getOwnPropertyDescriptor()`方法来获取这些属性。
代理使得你可以用`defineProperty`和`getOwnPropertyDescriptor`陷阱来对应拦截`Object.defineProperty()`和`Object.getOwnPropertyDescriptor()`调用。`defineProperty`陷阱接收以下参数：
1. `trapTarget` - 将要定义属性的对象（代理的目标）
2. `key` - 属性名字符串或symbol
3. `descriptor` - 属性的描述符对象

`defineProperty`陷阱要求你在操作成功时返回`true`，否则返回`false`。`getOwnPropertyDescriptor`陷阱只接收`trapTarget`和`key`，你需要返回该描述符。对象的`Reflect.defineProperty()`和`Reflect.getOwnPropertyDescriptor()`方法接受与它们对应代理陷阱相同的参数。这里有一个只为每个陷阱实现默认行为的例子：
```js
let proxy = new Proxy({}, {
  defineProperty(trapTarget, key, descriptor) {
    return Reflect.defineProperty(trapTarget, key, descriptor);
  },
  getOwnPropertyDescriptor(trapTarget, key) {
    return Reflect.getOwnPropertyDescriptor(trapTarget, key);
  }
});

Object.defineProperty(proxy, "name", {
  value: "proxy"
});

console.log(proxy.name);           // "proxy"

let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");

console.log(descriptor.value);     // "proxy"
```
这段代码使用`Object.defineProperty()`方法在代理上定义了一个名为`"name"`的属性。该属性的属性描述符接着通过`Object.getOwnPropertyDescriptor()`方法获取。
### 阻塞Object.defineProperty()
`defineProperty`陷阱要求你返回一个指示操作是否成功的布尔值。当返回`true`时，`Object.defineProperty()`像平常一样成功；当返回`false`时，`Object.defineProperty()`抛出一个错误。你可以使用这种功能来限制`Object.defineProperty()`方法可以定义的属性类型。例如，如果你想要避免定义symbol属性，你可以检查键是否为字符串并在不是时返回`false`，例如：
```js
let proxy = new Proxy({}, {

  defineProperty(trapTarget, key, descriptor) {
    if (typeof key === 'symbol') {
      return false
    }

    return Reflect.defineProperty(trapTarget, key, descriptor);
  }
});

Object.defineProperty(proxy, "name", {
  value: "proxy"
});

console.log(proxy.name);          // "proxy"

let nameSymbol = Symbol("name");

// 抛出错误
Object.defineProperty(proxy, nameSymbol, {
  value: "proxy"
});
```
`defineProperty`代理陷阱当`key`是symbol时返回`false`，否则将执行默认行为。当使用`"name"`作为`Object.defineProperty()`时，方法成功执行，因为键是一个字符串。当`Object.defineProperty()`与`nameSymbol`一起调用时，它抛出一个错误，因为`defineProperty`陷阱返回`false`。
你可以返回`true`来使`Object.defineProperty()`静默失败而不调用`Reflect.defineProperty()`方法。这将抑制错误抛出但并不会实际定义属性。
### 描述符对象限制
### 复制描述符方法
#### defineProperty()方法
#### getOwnPropertyDescriptor()方法
## `ownKeys`陷阱
## 使用`apply`和`construct`陷阱的函数代理
### 函数参数校验
### 不使用new调用构造函数
### 覆盖抽象基类构造函数
### 可调用类构造函数
## 可撤销代理
## 解决数组问题
### 检测数组索引
### 当新增元素时增加长度
### 减少长度时删除元素
### 实现MyArray类
## 将代理作为原型
### 在原型上使用`get`陷阱
### 在原型上使用`set`陷阱
### 在原型上使用`has`陷阱
### 作为类原型的代理
## 总结