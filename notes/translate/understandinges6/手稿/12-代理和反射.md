# 代理和反射API
ECMAScript5和ECMAScript6的发展都考虑到了解开JavaScript功能的神秘面纱。例如，JavaScript环境在ECMAScript5之前包含了不可枚举和不可写对象属性，但是开发人员无法定义自己的不可枚举或不可写属性。ECMAScript5包含了`Object.defineProperty()`方法来使得开发者完成JavaScript引擎早已可以做的事。
ECMAScript6给了开发者可以进一步访问以前仅适用于内置对象的JavaScript引擎能力。该语言通过*代理（proxies）*暴露了对象的内部工作方式，代理是可以拦截和更改JavaScript引擎底层操作的包装器。本章从详细介绍代理着力解决的问题开始，接着讨论你如何才能高效创建和使用代理。
## 数组问题
在ECMAScript6之前，JavaScript数组对象以开发人员无法通过自己的对象模拟的方式工作。一个数组的`length`属性在你复制给特定数组元素时发生变化，你也可以通过改变`length`属性来改变数组元素项。例如：
```js
let colors = ["red", "green", "blue"];

console.log(colors.length);     // 3

colors[3] = "black";

console.log(colors.length);     // 4
console.log(colors[3]);         // "black"

colors.length = 2;

console.log(colors.length);     // 2
console.log(colors[3]);         // undefined
console.log(colors[2]);         // undefined
console.log(colors[1]);         // "green"
```
`colors`数组开始有三项。将`"black"`赋给`colors[3]`自动将`length`属性增加到`4`。将`length`属性设为`2`移除了数组中的最后两项，只留下最开始的两项。ECMAScript5中没有允许开发者实现这种行为的方法，但是代理改变了它。
这种非标准行为就是数组在ECMAScript6中被视为怪异对象的原因。
## 什么是代理和反射
你可以通过调用`new Proxy()`创建一个代理来替代另外一个对象（被称为*目标（target）*）使用。代理*虚拟化*了目标，因此代理和目标在使用代理功能上看起来是相同的对象。
代理允许你拦截目标上的底层对象操作，否则这些操作将是JavaScript引擎内部的。这些底层操作通过一个*陷阱（trap）*拦截，一个陷阱是对应于一个特定操作的函数。
由`Reflect`对象表示的反射API是一个方法集合，这些方法为代理可重写的相同底层操作提供默认行为。每个代理陷阱都有一个`Reflect`方法。这些方法与对应代理陷阱有相同的名称并传入相同的参数。表11-1总结了这些行为：
|代理陷阱|重写的行为|默认行为|
|----------------------------|----------------------------|---------------------|
|`get`                       |读取一个属性值              |`Reflect.get()`      |
|`set`                       |写一个属性                  |`Reflect.set()`      |
|`has`                       |`in`操作符                  |`Reflect.has()`      |
|`deleteProperty`            |`delete`操作符              |`Reflect.deleteProperty()`  |
|`getPrototypeOf`            |`Object.getPrototypeOf()`   |`Reflect.getPrototypeOf()`  |
|`setPrototypeOf`            |`Object.setPrototypeOf()`   |`Reflect.setPrototypeOf()`  |
|`isExtensible`              |`Object.isExtensible()`     |`Reflect.isExtensible()`    |
|`preventExtensions`         |`Object.preventExtensions()`  |`Reflect.preventExtensions()` |
|`getOwnPropertyDescriptor`  |`Object.getOwnPropertyDescriptor()` |`Reflect.getOwnPropertyDescriptor()` |
|`defineProperty`            |`Object.defineProperty()`   |`Reflect.defineProperty()`  |
|`ownKeys`                   |`Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`  |`Reflect.ownKeys()`    |
|`apply`                     |调用一个函数                |`Reflect.apply()`     |
|`construct`                 |使用`new`调用一个函数         |`Reflect.construct()` |
每个陷阱都重写了JavaScript对象的一些内置行为，允许你拦截并修改这些行为。如果你仍需使用这些内置行为，那么你可以使用对应的反射API方法。代理和反射API的关系当你开始创建代理时变得清晰，因此最好开始看一些例子。
初始的ECMAScript6标准有一个额外的`enumerate`陷阱，它被设计来替代`for-in`和`Object.keys()`是如何枚举对象上的属性的。然而，`enumerate`陷阱在ECMAScript7（也被称为ECMAScript 2016）中因为实现过程中发现的困难而被移除。`enumerate`陷阱不再存在于任何JavaScript环境中，因此并没有包含在本章中。
## 创建一个简单代理
当你使用`Proxy`构造函数创建一个代理时，你需要向它传两个参数：目标和处理器。一个*处理器*时一个定义了一个或多个陷阱的对象。代理为所有的操作使用默认行为，除非为该操作定义了陷阱。为了创建一个简单的转发代理，你可以使用一个没有任何陷阱的处理器：
```js
let target = {};

let proxy = new Proxy(target, {});

proxy.name = "proxy";
console.log(proxy.name);           // "proxy"
console.log(target.name);          // "proxy"

target.name = "target";
console.log(proxy.name);           // "target"
console.log(target.name);          // "target"
```
在这个例子中，`proxy`直接向`target`转发了所有操作。当`"proxy"`被赋值给`proxy.name`属性时，`name`被创建在`target`上。代理自身并不存储这个属性，它只是简单的向`target`转发这个操作。类似地，`proxy.name`和`target.name`是相同的，因为它们都引用自`target.name`。这同时表示给`target.name`设置新值将导致`proxy.name`反射出相同的改变。当然，没有任何陷阱的代理并不十分吸引人，那么当你定义了一个陷阱时将会发生什么？
## 使用`set`陷阱验证属性
## 使用`get`陷阱验证对象形状
## 使用`has`陷阱隐藏属性的存在
## 使用`deleteProperty`陷阱避免属性删除
## 原型代理陷阱
### 原型代理陷阱如何工作
### 为什么有两套方法？
## 对象扩展陷阱
### 两个基础例子
### 复制扩展性方法
## 属性描述符陷阱
### 阻塞Object.defineProperty()
### 描述符对象限制
### 复制描述符方法
#### defineProperty()方法
#### getOwnPropertyDescriptor()方法
## `ownKeys`陷阱
## 使用`apply`和`construct`陷阱的函数代理
### 函数参数校验
### 不使用new调用构造函数
### 覆盖抽象基类构造函数
### 可调用类构造函数
## 可撤销代理
## 解决数组问题
### 检测数组索引
### 当新增元素时增加长度
### 减少长度时删除元素
### 实现MyArray类
## 将代理作为原型
### 在原型上使用`get`陷阱
### 在原型上使用`set`陷阱
### 在原型上使用`has`陷阱
### 作为类原型的代理
## 总结