# 代理和反射API
ECMAScript5和ECMAScript6的发展都考虑到了解开JavaScript功能的神秘面纱。例如，JavaScript环境在ECMAScript5之前包含了不可枚举和不可写对象属性，但是开发人员无法定义自己的不可枚举或不可写属性。ECMAScript5包含了`Object.defineProperty()`方法来使得开发者完成JavaScript引擎早已可以做的事。
ECMAScript6给了开发者可以进一步访问以前仅适用于内置对象的JavaScript引擎能力。该语言通过*代理（proxies）*暴露了对象的内部工作方式，代理是可以拦截和更改JavaScript引擎底层操作的包装器。本章从详细介绍代理着力解决的问题开始，接着讨论你如何才能高效创建和使用代理。
## 数组问题
在ECMAScript6之前，JavaScript数组对象以开发人员无法通过自己的对象模拟的方式工作。一个数组的`length`属性在你复制给特定数组元素时发生变化，你也可以通过改变`length`属性来改变数组元素项。例如：
```js
let colors = ["red", "green", "blue"];

console.log(colors.length);     // 3

colors[3] = "black";

console.log(colors.length);     // 4
console.log(colors[3]);         // "black"

colors.length = 2;

console.log(colors.length);     // 2
console.log(colors[3]);         // undefined
console.log(colors[2]);         // undefined
console.log(colors[1]);         // "green"
```
`colors`数组开始有三项。将`"black"`赋给`colors[3]`自动将`length`属性增加到`4`。将`length`属性设为`2`移除了数组中的最后两项，只留下最开始的两项。ECMAScript5中没有允许开发者实现这种行为的方法，但是代理改变了它。
这种非标准行为就是数组在ECMAScript6中被视为怪异对象的原因。
## 什么是代理和反射
你可以通过调用`new Proxy()`创建一个代理来替代另外一个对象（被称为*目标（target）*）使用。代理*虚拟化*了目标，因此代理和目标在使用代理功能上看起来是相同的对象。
代理允许你拦截目标上的底层对象操作，否则这些操作将是JavaScript引擎内部的。这些底层操作通过一个*陷阱（trap）*拦截，一个陷阱是对应于一个特定操作的函数。
由`Reflect`对象表示的反射API是一个方法集合，这些方法为代理可重写的相同底层操作提供默认行为。每个代理陷阱都有一个`Reflect`方法。这些方法与对应代理陷阱有相同的名称并传入相同的参数。表11-1总结了这些行为：
|代理陷阱|重写的行为|默认行为|
|----------------------------|----------------------------|---------------------|
|`get`                       |读取一个属性值              |`Reflect.get()`      |
|`set`                       |写一个属性                  |`Reflect.set()`      |
|`has`                       |`in`操作符                  |`Reflect.has()`      |
|`deleteProperty`            |`delete`操作符              |`Reflect.deleteProperty()`  |
|`getPrototypeOf`            |`Object.getPrototypeOf()`   |`Reflect.getPrototypeOf()`  |
|`setPrototypeOf`            |`Object.setPrototypeOf()`   |`Reflect.setPrototypeOf()`  |
|`isExtensible`              |`Object.isExtensible()`     |`Reflect.isExtensible()`    |
|`preventExtensions`         |`Object.preventExtensions()`  |`Reflect.preventExtensions()` |
|`getOwnPropertyDescriptor`  |`Object.getOwnPropertyDescriptor()` |`Reflect.getOwnPropertyDescriptor()` |
|`defineProperty`            |`Object.defineProperty()`   |`Reflect.defineProperty()`  |
|`ownKeys`                   |`Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`  |`Reflect.ownKeys()`    |
|`apply`                     |调用一个函数                |`Reflect.apply()`     |
|`construct`                 |使用`new`调用一个函数         |`Reflect.construct()` |
每个陷阱都重写了JavaScript对象的一些内置行为，允许你拦截并修改这些行为。如果你仍需使用这些内置行为，那么你可以使用对应的反射API方法。代理和反射API的关系当你开始创建代理时变得清晰，因此最好开始看一些例子。
初始的ECMAScript6标准有一个额外的`enumerate`陷阱，它被设计来替代`for-in`和`Object.keys()`是如何枚举对象上的属性的。然而，`enumerate`陷阱在ECMAScript7（也被称为ECMAScript 2016）中因为实现过程中发现的困难而被移除。`enumerate`陷阱不再存在于任何JavaScript环境中，因此并没有包含在本章中。
## 创建一个简单代理
当你使用`Proxy`构造函数创建一个代理时，你需要向它传两个参数：目标和处理器。一个*处理器*时一个定义了一个或多个陷阱的对象。代理为所有的操作使用默认行为，除非为该操作定义了陷阱。为了创建一个简单的转发代理，你可以使用一个没有任何陷阱的处理器：
```js
let target = {};

let proxy = new Proxy(target, {});

proxy.name = "proxy";
console.log(proxy.name);           // "proxy"
console.log(target.name);          // "proxy"

target.name = "target";
console.log(proxy.name);           // "target"
console.log(target.name);          // "target"
```
在这个例子中，`proxy`直接向`target`转发了所有操作。当`"proxy"`被赋值给`proxy.name`属性时，`name`被创建在`target`上。代理自身并不存储这个属性，它只是简单的向`target`转发这个操作。类似地，`proxy.name`和`target.name`是相同的，因为它们都引用自`target.name`。这同时表示给`target.name`设置新值将导致`proxy.name`反射出相同的改变。当然，没有任何陷阱的代理并不十分吸引人，那么当你定义了一个陷阱时将会发生什么？
## 使用`set`陷阱验证属性
假设你想创建一个属性值必需为数字的对象。这表明添加到该对象上的每个新属性都必需被验证，如果值不是一个数字那么必需抛出一个错误。为了实现它，你可以定义一个重写设置值行为的`set`陷阱。这个`set`陷阱接收四个参数：
1. `trapTarget` - 将接收该属性的对象（代理的目标）
2. `key` - 将写入的属性键（字符串或者symbol）
3. `value` - 将写入该属性的值
4. `receiver` - 操作将发生的对象（通常为代理）

`Reflect.set()`是`set`陷阱对应的反射方法，也是该操作的默认行为。`Reflect.set()`方法接收与`set`代理陷阱相同的四个参数，使该方法在陷阱内易于使用。该陷阱在属性被设置时返回`true`，否则返回`false`。（`Reflect.set()`方法根据操作是否成功返回正确的值。）
为了验证属性的值，你可以使用`set`陷阱检查传入的`value`。这里有一个例子：
```js
let target = {
  name: "target"
};

let proxy = new Proxy(target, {
  set(trapTarget, key, value, receiver) {

    // 忽略已有的属性从而不影响到它们
    if (!trapTarget.hasOwnProperty(key)) {
      if (isNaN(value)) {
        throw new TypeError("Property must be a number.")
      }
    }

    // 新增属性
    return Reflect.set(trapTarget, key, value, receiver);
  }
});

// 增加一个新的属性
proxy.count = 1
console.log(proxy.count);       // 1
console.log(target.count);      // 1

// 你可以赋值给name，因为它已经存在于目标上
proxy.name = "proxy";
console.log(proxy.name);        // "proxy"
console.log(target.name);        // "proxy"

// 抛出一个错误
proxy.anotherName = "proxy";
```
这段代码定义了一个代理陷阱，它验证任何新增到`target`上的属性值。当`proxy.count = 1`被执行时，`set`陷阱被调用。`trapTarget`值等于`target`，`key`是`"count"`，`value`是`1`，`receiver`（本例中并没有被使用）是`proxy`。`target`上并不存在名为`count`的属性，因此代理将通过把`value`传给`isNaN()`来验证它。如果结果是`NaN`，那么属性值不是数值，将抛出一个错误。由于代码将`count`设为`1`，代理使用与传给陷阱相同的四个参数调用`Reflect.set()`来添加新的属性。
当赋一个字符串给`proxy.name`时，操作成功完成。因为`target`已经有一个`name`属性，该属性在调用`trapTarget.hasOwnProperty()`方法时避免了有效性检查。这确保了已存在的非数值属性依旧被支持。
然而当赋一个字符串给`proxy.anotherName`时将抛出一个错误。`anotherName`属性并不存在于目标上，因此该值需要被验证。在验证时，由于`"proxy"`不是一个数值而抛出一个错误。
`set`代理陷阱使得你可以在属性被写入时拦截，`get`代理陷阱使得你可以在属性被读取时拦截。
## 使用`get`陷阱验证对象形状
JavaScript的一个最有意思，有时也很迷惑人的方面在于读取一个不存在的属性并不抛出一个错误。反而，值undefined将作为它的属性值，如下例所示：
```js
let target = {};

console.log(target.name);       // undefined
```
在其它多数语言中，试图读取`target.name`将抛出一个错误，因为该值并不存在。但是JavaScript只是使用`undefined`来表示`target.name`属性的值。如果你曾经处理过大型代码库，那么你可能已经见过这种行为将导致多少问题，尤其是当属性名拼写错误时。代理可以通过对象形状验证来使你避免这些问题。
一个*对象形状*是对象上可访问属性和方法的集合。JavaScript引擎使用对象形状来优化代码，通常创建类来表示对象。如果你可以安全地假设一个对象将总是具备某些相同的属性以及它开始时具有的方法（一种可以使用`Object.preventExtensions()`, `Object.seal()`或`Object.freeze()`方法强制执行的行为），那么在试图访问不存在的属性时抛出一个错误将很有用。代理使得对象形状验证更简单。
由于属性验证只在该属性被读取的时候发生，你可以使用`get`陷阱。`get`陷阱在一个属性被读取时调用，即使该属性不存在于对象上，它有三个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要读取的属性键（一个字符串或者一个symbol）
3. `receiver` - 操作发生的对象（通常是代理）

这些参数与`set`陷阱参数相同，但有一个明显的不同。由于`get`陷阱并不写入值，此处没有`value`参数。`Reflect.get()`方法接收与`get`陷阱相同的三个参数并返回属性的默认值。
你可以使用`get`陷阱和`Reflect.get()`来当一个属性不存在于目标上时抛出一个错误，如下：
```js
let proxy = new Proxy({}, {
  get(trapTarget, key, receiver) {
    if (!(key in receiver)) {{
      throw new TypeError("Property " + key + " doesn't exist.");
    }}

    return Reflect.get(trapTarget, key, receiver);
  }
});

// 添加一个属性时正常工作
proxy.name = "proxy";
console.log(proxy.name);      // "proxy"

// 访问不存在的属性时将抛出一个错误
console.log(proxy.nme);       // 抛出一个错误
```
在这个例子中，`get`陷阱拦截属性读取操作。`in`操作被用来判断属性是否已经存在于`receiver`上。`receiver`与`in`一起使用，而非`trapTarget`，以防`receiver`是一个有`has`陷阱的代理，这将在下一节中讨论。在此例下使用`trapTarget`将避免`has`陷阱从而坑你导致错误的结果。如果属性不存在，那么将抛出一个错误，否则将使用默认行为。
这段代码允许添加`proxy.name`等新属性，并正常写入或读取。最后一行包含了一个拼写错误：`proxy.nme`应该是`proxy.name`。这将抛出一个错误，因为`nme`不作为一个属性存在。
## 使用`has`陷阱隐藏属性的存在
`in`操作符决定了一个属性是否存在于给定对象上并在已有一个自有属性或原型属性匹配属性名或symbol时返回`true`。例如：
```js
let target = {
  value: 42
};

console.log("value" in target);          // true
console.log("toString" in target);       // true
```
`value`和`toString`都存在于`object`上，因此两个`in`操作符例子都返回`true`。`value`属性是一个自有属性而`toString`是一个原型属性（从`Object`继承）。代理可以允许你使用`has`陷阱拦截此行为并为`in`返回不同值。
`has`陷阱在使用`in`操作符时被调用。当被调用时，`has`陷阱被传入了两个参数：
1. `trapTarget` - 属性被读取的对象（代理的目标）
2. `key` - 要检查的属性值（字符串或者symbol）

`Reflect.has()`方法接受相同的参数并返回`in`操作符的默认响应。使用`has`陷阱和`Reflect.has()`允许替换一些属性的`in`行为，而为其它的使用默认行为。例如，假设你想要隐藏`value`属性。你可以如下实现：
```js
let target = {
  name: "target",
  value: 42
};


let proxy = new Proxy(target, {
  has(trapTarget, key) {

    if (key === 'value') {
      return false;
    } else {
      return Reflect.has(trapTarget, key);
    }
  }
});

console.log("value" in proxy);          // false
console.log("name" in proxy);           // true
console.log("toString" in proxy);       // true
```
`proxy`的`has`陷阱检查`key`是否为`"value"`，并在是的时候返回`false`。否则，通过调用`Reflect.has()`方法来执行默认行为。最终，`in`操作符在检查`value`属性时返回`false`，虽然`value`确实存在于目标上。其它的属性，`name`和`toString`，正确地在`in`操作符时返回`true`。
## 使用`deleteProperty`陷阱避免属性删除
`delete`操作符移除对象上的一个属性并在成功时返回`true`，失败时返回`false`。在严格模式下，`delete`在你试图删除一个非可配置属性时将抛出一个错误，在非严格模式下，`delete`简单返回`false`。下面为一个例子：
```js
let target = {
  name: "target",
  value: 42
};

Object.defineProperty(target, "name", { configurable: false });

console.log("value" in target);        // true

let result1 = delete target.value;
console.log(result1);                  // true

console.log("value" in target);        // false

// 注意：下面的代码行将在严格模式下抛出一个错误
let result2 = delete target.name;
console.log(result2);                  // false

console.log("name" in target);         // true
```
`value`属性被`delete`操作符删除，因此`in`操作符在第三个`console.log()`调用中返回`false`。不可配置属性`name`无法被删除，因此`delete`操作符简单返回`false`（如果代码在严格模式下运行，将抛出一个错误）。你可以通过在代理中使用`deleteProperty`陷阱来替代这种行为。
`deleteProperty`陷阱在对象属性上使用`delete`操作符时被调用。该陷阱被传入两个参数：
1. `trapTarget` - 要删除属性的对象（代理的目标）
2. `key` - 要删除的属性键（字符串或者symbol）

`Reflect.deleteProperty()`方法提供了`deleteProperty`陷阱的默认实现，并接受相同的两个参数。你可以组合使用`Reflect.deleteProperty()`和`deleteProperty`陷阱来改变`delete`操作符的行为。例如，你可以确保`value`属性不可被删除：
```js
let target = {
   name: "target",
   value: 42
};

let proxy = new Proxy(target, {
  deleteProperty(trapTarget, key) {

    if (key === "value") {
      return false;
    } else {
      return Reflect.deleteProperty(trapTarget, key);
    }
  }
});

// 试图删除proxy.value

console.log("value" in proxy);        // true

let result1 = delete proxy.value;
console.log(result1);                // false

console.log("value" in proxy);       // true

// 试图删除proxy.name
console.log("name" in proxy);        // true
let result2 = delete proxy.name;
console.log(result2);                // true

console.log("name" in proxy);        // false
```
该代码与`has`陷阱一例十分相似，`deleteProperty`陷阱检查`key`是否是`"value"`，是的时候返回`false`。否则，调用`Reflect.deleteProperty()`方法执行默认行为。`value`属性无法通过`proxy`删除，因为该操作被拦截，但`name`属性可以按预想的被删除。该方法在你想要在严格模式下保护某些属性不被删除而不抛出错误时非常有用。
## 原型代理陷阱
第四章介绍了`Object.setPrototypeOf()`方法，它是ECMAScript6中新增的ECMAScript5`Object.getPrototypeOf()`方法的补充。代理允许你通过`setPrototypeOf`和`getPrototypeOf`陷阱来拦截它们的执行。在这两种情况下，Object的方法调用代理上对应名称的陷阱，允许你替换方法的行为。
由于有两个关于原型代理的陷阱，因此每个类型的陷阱都有一组对应的方法。`setPrototypeOf`陷阱接受以下参数：
1. `trapTarget` - 需要设置原型的对象（代理的目标）
2. `proto` - 用作原型的对象

相同的参数将传递给`Object.setPrototypeOf()`和`Reflect.setPrototypeOf()`方法。此外，`getPrototypeOf`陷阱只接受`trapTarget`参数，它也将作为参数传给`Object.getPrototypeOf()`和`Reflect.getPrototypeOf()`方法。
### 原型代理陷阱如何工作
这些陷阱有一些限制。首先，`getPrototypeOf`陷阱必须返回一个对象或者`null`，任何其它返回值都将导致一个运行时错误。返回值检查确保`Object.getPrototypeOf()`将总是返回一个预料中的值。类似的的，`setPrototypeOf`陷阱的返回值必须在操作不成功时为`false`。当`setPrototypeOf`返回`false`时，`Object.setPrototypeOf()`抛出一个错误。如果`setPrototypeOf`返回除了`false`的其它值，`Object.setPrototypeOf()`假设操作是成功的。
下面的例子通过总是返回`null`隐藏了代理的原型并不允许原型被改变：
```js
let target = {};
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return null;
  },
  setPrototypeOf(trapTarget, proto) {
    return false;
  }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);       // true
console.log(proxyProto === Object.prototype);        // false
console.log(proxyProto);                             // null

// 成功
Object.setPrototypeOf(target, {});


// 抛出错误
Object.setPrototypeOf(proxy, {});
```
这段代码强调了`target`和`proxy`之间的区别。虽然`Object.getPrototypeOf()`为`target`返回了一个值，但为`proxy`返回了一个`null`，因为`getPrototypeOf`陷阱被调用。类似地，因为`setPrototypeOf`的存在，`Object.setPrototypeOf()`在`target`上成功调用，但在`proxy`上抛出错误。
如果你想要使用这两个陷阱的默认行为，你可以使用Reflect上的对应方法。例如，下面的代码实现了getPrototypeOf和setPrototypeOf陷阱的默认行为：
```js
let target = {};
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return Reflect.getPrototypeOf(trapTarget);
  },
  setPrototypeOf(trapTarget, proto) {
    return Reflect.setPrototypeOf(trapTarget, proto);
  }
});

let targetProto = Object.getPrototypeOf(target);
let proxyProto = Object.getPrototypeOf(proxy);

console.log(targetProto === Object.prototype);       // true
console.log(proxyProto === Object.prototype);        // true

// 成功
Object.setPrototypeOf(target, {});

// 也成功
Object.setPrototypeOf(proxy, {});
```
在这个例子中，你可以交换使用`target`和`proxy`并获得相同的结果，因为`getPrototypeOf`和`setPrototypeOf`陷阱只是透传并使用默认实现行为。由于一些重要的差别，本例中使用`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`方法而不是`Object`上的同名方法，这非常重要。
### 为什么有两套方法？
`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`使人迷惑之处在于它们看起来与`Object.getPrototypeOf()`和`Object.setPrototypeOf()`方法非常相似。虽然这两组方法执行相似的操作，它们之间有着明显的差异。
最初`Object.getPrototypeOf()`和`Object.setPrototypeOf()`是为了开发人员使用而创建的高级操作。`Reflect.getPrototypeOf()`和`Reflect.setPrototypeOf()`方法是给开发人员访问之前内部的`[[GetPrototypeOf]]`和`[[SetPrototypeOf]]`操作的低级操作。`Reflect.getPrototypeOf()`方法是内部`[[GetPrototypeOf]]`操作（有一些输入校验）的包装器。`Reflect.setPrototypeOf()`方法和`[[SetPrototypeOf]]`有相同的关系。`Object`上对应的方法也调用`[[GetPrototypeOf]]`和`[[SetPrototypeOf]]`，但是在调用前会执行几步并检查返回值来决定后续行为。
`Reflect.getPrototypeOf()`方法在参数不是对象时将抛出一个错误，而`Object.getPrototypeOf()`在执行操作之前首先会将值强制转换为一个对象。如果你错误地传入了一个数值给这两个方法，你将获得不同的结果：
```js
let result1 = Object.getPrototypeOf(1);
console.log(result1 === Number.prototype);    // true

// 抛出错误
Reflect.getPrototypeOf(1);
```
`Object.getPrototypeOf()`方法允许你获取数值`1`的原型，因为它首先将值强制转换为`Number`对象并返回`Number.prototype`。`Reflect.getPrototypeOf()`方法不会强制转换值，因为`1`不是一个对象，它将抛出一个错误。
`Reflect.setPrototypeOf()`方法也和`Object.setPrototypeOf()`方法之间有一些差别。首先，`Reflect.setPrototypeOf()`返回一个指示操作是否成功的布尔值。成功时返回`true`，失败时返回`false`。如果`Object.setPrototypeOf()`失败，它抛出错误。
如“原型代理陷阱如何工作”中第一个例子所示，当`setPrototypeOf`代理陷阱返回`false`时，它导致`Object.setPrototypeOf`抛出一个错误。`Object.setPrototypeOf()`方法返回第一个参数作为它的值，因此并不适合作为`setPrototypeOf`代理陷阱的默认行为实现。下面的代码解释了这些差异：
```js
let target1 = {};
let result1 = Object.setPrototypeOf(target1, {});
console.log(result1 === target1);                 // true

let target2 = {};
let result2 = Reflect.setPrototypeOf(target2, {});
console.log(result2 === target2);                 // false
console.log(result2);                             // true
```
在这个例子中，`Object.setPrototypeOf()`返回`target1`作为它的值，但是`Reflect.setPrototypeOf()`返回`true`。这些细微差别非常重要。你将在`Object`和`Reflect`上看到更多看起来重复的方法，但请总是在代理陷阱内部使用`Reflect`。
当在代理上使用时，这两组方法都将调用`getPrototypeOf`和`setPrototypeOf`代理陷阱。
## 对象扩展陷阱
ECMAScript5通过`Object.preventExtensions()`和`Object.isExtensible()`方法增加了对象扩展性修改，ECMAScript6允许通过`preventExtensions`和`isExtensible`陷阱来拦截这些方法调用底层对象。这两个方法都接收一个名为trapTarget的单独参数，它是方法调用的对象。`isExtensible`陷阱必须返回一个指示该对象是否可扩展的布尔值，而`preventExtensions`陷阱则返回一个指示操作是否成功的布尔值。
也有`Reflect.preventExtensions()`和`Reflect.isExtensible()`方法来实现默认行为。它们都返回布尔值，所以可以直接在对应的陷阱里使用它们。
### 两个基础例子
为了实际查看对象扩展性陷阱，考虑以下代码，它实现了`isExtensible`和`preventExtensions`陷阱的默认行为：
```js
let target = {};
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget);
  },
  preventExtensions(trapTarget) {
    return Reflect.preventExtensions(trapTarget);
  }
});

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));         // false
console.log(Object.isExtensible(proxy));          // false
```
如本例所示，`Object.preventExtensions()`和`Object.isExtensible()`正确地在`proxy`和`target`间传递。你当然也可以改变行为。例如，如果你不想允许`Object.preventExtensions()`在代理上成功执行，你可以从`preventExtensions`陷阱中返回`false`：
```js
let target = {};
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget);
  },
  preventExtensions(trapTarget) {
    return false;
  }
});

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true

Object.preventExtensions(proxy);

console.log(Object.isExtensible(target));         // true
console.log(Object.isExtensible(proxy));          // true
```
此处`Object.preventExtensions(proxy)`调用没有生效，因为`preventExtensions`陷阱返回`false`。操作并没有转发给底层`target`，因此`Object.isExtensible()`返回`true`。
### 重复的扩展性方法
再次，你可能已经注意到，`Object`和`Reflect`上有重复的方法。在这个例子中，它们更多地是相似。`Object.isExtensible()`和`Reflect.isExtensible()`除了在传入一个非对象值以外很相似。在那种情况下，`Object.isExtensible()`总是返回`false`而`Reflect.isExtensible()`抛出一个错误。下面有一个这种行为的例子：
```js
let result1 = Object.isExtensible(2);
console.log(result1);                // false

// 抛出错误
let result2 = Reflect.isExtensible(2)
```
这种限制和`Object.getPrototypeOf()`和`Reflect.getPrototypeOf()`方法间的差别相似，因为低层功能方法比高层方法有着更严格的错误检测。
`Object.preventExtensions()`和`Reflect.preventExtensions()`方法也很相似。`Object.preventExtensions()`方法总是讲作为参数传入的值返回，即使它不是一个对象。然而`Reflect.preventExtensions()`方法在参数不为对象时抛出一个错误。如果参数是一个对象，那么`Reflect.preventExtensions()`在操作成功时返回`true`，否则返回`false`。例如：
```js
  let result1 = Object.preventExtensions(2);
  console.log(result1);                      // 2


  let target = {};
  let result2 = Reflect.preventExtensions(target);
  console.log(result2);                      // true

  // 抛出错误
  let result3 = Reflect.preventExtensions(2);
```
这里，`Object.preventExtensions()`将`2`作为返回值传递，即使`2`不是一个对象。`Reflect.preventExtensions()`方法当对象传递给它时返回`true`，而当`2`传入时抛出错误。
## 属性描述符陷阱
在JavaScript之前的版本中，没有方法来定义访问器属性、使得属性只读或不可枚举。这些都可以使用`Object.defineProperty()`方法来实现，你可以通过`Object.getOwnPropertyDescriptor()`方法来获取这些属性。
代理使得你可以用`defineProperty`和`getOwnPropertyDescriptor`陷阱来对应拦截`Object.defineProperty()`和`Object.getOwnPropertyDescriptor()`调用。`defineProperty`陷阱接收以下参数：
1. `trapTarget` - 将要定义属性的对象（代理的目标）
2. `key` - 属性名字符串或symbol
3. `descriptor` - 属性的描述符对象

`defineProperty`陷阱要求你在操作成功时返回`true`，否则返回`false`。`getOwnPropertyDescriptor`陷阱只接收`trapTarget`和`key`，你需要返回该描述符。对象的`Reflect.defineProperty()`和`Reflect.getOwnPropertyDescriptor()`方法接受与它们对应代理陷阱相同的参数。这里有一个只为每个陷阱实现默认行为的例子：
```js
let proxy = new Proxy({}, {
  defineProperty(trapTarget, key, descriptor) {
    return Reflect.defineProperty(trapTarget, key, descriptor);
  },
  getOwnPropertyDescriptor(trapTarget, key) {
    return Reflect.getOwnPropertyDescriptor(trapTarget, key);
  }
});

Object.defineProperty(proxy, "name", {
  value: "proxy"
});

console.log(proxy.name);           // "proxy"

let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");

console.log(descriptor.value);     // "proxy"
```
这段代码使用`Object.defineProperty()`方法在代理上定义了一个名为`"name"`的属性。该属性的属性描述符接着通过`Object.getOwnPropertyDescriptor()`方法获取。
### 阻塞Object.defineProperty()
`defineProperty`陷阱要求你返回一个指示操作是否成功的布尔值。当返回`true`时，`Object.defineProperty()`像平常一样成功；当返回`false`时，`Object.defineProperty()`抛出一个错误。你可以使用这种功能来限制`Object.defineProperty()`方法可以定义的属性类型。例如，如果你想要避免定义symbol属性，你可以检查键是否为字符串并在不是时返回`false`，例如：
```js
let proxy = new Proxy({}, {

  defineProperty(trapTarget, key, descriptor) {
    if (typeof key === 'symbol') {
      return false
    }

    return Reflect.defineProperty(trapTarget, key, descriptor);
  }
});

Object.defineProperty(proxy, "name", {
  value: "proxy"
});

console.log(proxy.name);          // "proxy"

let nameSymbol = Symbol("name");

// 抛出错误
Object.defineProperty(proxy, nameSymbol, {
  value: "proxy"
});
```
`defineProperty`代理陷阱当`key`是symbol时返回`false`，否则将执行默认行为。当使用`"name"`作为`Object.defineProperty()`时，方法成功执行，因为键是一个字符串。当`Object.defineProperty()`与`nameSymbol`一起调用时，它抛出一个错误，因为`defineProperty`陷阱返回`false`。
你可以返回`true`来使`Object.defineProperty()`静默失败而不调用`Reflect.defineProperty()`方法。这将抑制错误抛出但并不会实际定义属性。
### 描述符对象限制
为了确保使用`Object.defineProperty()`和`Object.getOwnPropertyDescriptor()`方法的行为一致性，传给`defineProperty`陷阱的描述符对象被规范化了。从`getOwnPropertyDescriptor`陷阱的对象也总将因相同原因而被验证。
无论传给`Object.defineProperty()`方法的是什么对象，只有`enumerable`，`configurable`，`value`，`writable`，`get`和`set`属性将在描述符对象上被传给`defineProperty`陷阱。例如：
```js
let proxy = new Proxy({}, {
  defineProperty(trapTarget, key, descriptor) {
    console.log(descriptor.value);          // proxy
    console.log(descriptor.name);           // undefined

    return Reflect.defineProperty(trapTarget, key, descriptor);
  }
});

Object.defineProperty(proxy, "name", {
  value: "proxy",
  name: "custom"
});
```
此处，`Object.defineProperty()`与第三个参数上的非标准`name`属性被调用。当`defineProperty`陷阱调用时，`descriptor`对象没有`name`属性但有value属性。这是因为`descriptor`不是实际传给`Object.defineProperty()`方法的第三个参数的引用，而是一个只包含允许的属性的新对象。`Reflect.defineProperty()`方法也将忽略描述符上的任何非标准属性。
getOwnPropertyDescriptor陷阱有一个微小的差异限制，它要求返回值为null，undefined或一个对象。如果一个对象被返回，只有`enumerable`，`configurable`，`value`，`writable`，`get`和`set`被允许为对象的自有属性。如果你返回一个含不允许的自有属性的对象，那么将抛出一个错误，如下面的代码所示：
```js
let proxy = new Proxy({}, {
  getOwnPropertyDescriptor(trapTarget, key) {
    return {
      name: "proxy"
    };
  }
});

// 抛出错误
let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");
```
属性`name`在属性描述符中是不被允许的，因此当`Object.getOwnPropertyDescriptor()`被调用时，`getOwnPropertyDescriptor`返回值触发了一个错误。这个限制保证了`Object.getOwnPropertyDescriptor()`的返回值将总是返回一个可信任的结构而无论是否在代理上使用。
### 重复的描述符方法
再次，ECMAScript6有一些令人迷惑的相似方法，`Object.defineProperty()`和`Object.getOwnPropertyDescriptor()`方法看起来对应与`Reflect.defineProperty()`和`Reflect.getOwnPropertyDescriptor()`方法做相同的事。像本章中之前讨论过的方法对，它们也有一些微小但重要的差别。
#### defineProperty()方法
`Object.defineProperty()`和`Reflect.defineProperty()`方法除了返回值以外都完全相同。`Object.defineProperty()`方法必须返回第一个参数，而`Reflect.defineProperty()`在操作成功时返回`true`，否则返回`false`。例如：
```js
let target = {};

let result1 = Object.defineProperty(target, "name", { value: "target" });

console.log(target === result1);            // true

let result2 = Reflect.defineProperty(target, "name", { value: "reflect" });
console.log(result2);                       // true（实测为false，重复定义name了）
```
当在`target`上使用`Object.defineProperty()`时，返回值是`target`。当在`target`上使用`Reflect.defineProperty()`时，返回值是`true`，表示操作成功。由于`defineProperty`代理陷阱要求返回一个布尔值，因此最好在需要时使用`Reflect.defineProperty()`来实现默认行为。
#### getOwnPropertyDescriptor()方法
`Object.getOwnPropertyDescriptor()`方法将强制转换它的第一个参数为对象，如果被传入的是原始值，并将继续操作。然而，当第一个参数是原始值时`Reflect.getOwnPropertyDescriptor()`方法将抛出一个错误。下面的例子展示了这两种情况：
```js
let descriptor1 = Object.getOwnPropertyDescriptor(2, "name");
console.log(descriptor1);             // undefined

// 抛出一个错误
let descriptor2 = Reflect.getOwnPropertyDescriptor(2, "name");
```
`Object.getOwnPropertyDescriptor()`方法将返回`undefined`，因为它强制转换2为一个对象，而该对象没有`name`属性。这是对象上找不到指定名称属性时方法的标准行为。然而当调用`Reflect.getOwnPropertyDescriptor()`时，将立刻抛出一个错误，因为方法不接受原始值作为第一个参数。
## `ownKeys`陷阱
`ownKeys`代理陷阱拦截内部方法`[[OwnPropertyKeys]]`并允许你通过返回一个值的数组来重写行为。该数组将在四个方法中使用：`Object.keys()`方法，`Object.getOwnPropertyNames()`方法，`Object.getOwnPropertySymbols()`方法和`Object.assign()`方法。（`Object.assign()`方法使用数组来决定复制哪些属性。）
`ownKeys`陷阱的默认行为由`Reflect.ownKeys()`方法实现，并返回一个所有自有属性键的数组，包含所有的字符串和symbol。`Object.getOwnPropertyNames()`方法和`Object.keys()`方法从数组中过滤掉所有symbol后返回，而`Object.getOwnPropertySymbols()`从数组中过滤掉所有字符串后返回。`Object.assign()`方法使用字符串和symbol。
`ownKeys`陷阱接受一个单独的参数，目标，并必须总是返回一个数组或类数组对象，否则将抛出一个错误。例如，你可以使用`ownKeys`陷阱来过滤掉一些你不想在使用`Object.keys()`，`Object.getOwnPropertyNames()`，`Object.getOwnPropertySymbols()`和`Object.assign()`方法时包含的特定属性键。假设你不想包含任何由下划线开头的属性(一种JavaScript中常见的表示属性私有的做法。）你可以像下面一样使用`ownKeys`陷阱来过滤掉这些属性：
```js
let proxy = new Proxy({}, {
  ownKeys(trapTarget) {
    return Reflect.ownKeys(trapTarget).filter(key => {
      return typeof key !== "string" || key[0] !== "_";
    });
  }
});

let nameSymbol = Symbol("name");

proxy.name = "proxy";
proxy._name = "private";
proxy[nameSymbol] = "symbol";

let names = Object.getOwnPropertyNames(proxy),
    keys = Object.keys(proxy),
    symbols = Object.getOwnPropertySymbols(proxy);

console.log(names.length);      // 1
console.log(names[0]);          // "name"

console.log(keys.length);       // 1
console.log(keys[0]);           // "name"

console.log(symbols.length);    // 1
console.log(symbols[0]);        // "Symbol(name)"
```
本例中使用了一个`ownKeys`陷阱，它首先调用`Reflect.ownKeys()`来获取目标的默认键列表。然后使用`filter()`方法来过滤掉由下划线开头的字符串键。接着，`proxy`对象上新增了三个属性：`name`，`_name`和`nameSymbol`。当在`proxy`上调用`Object.getOwnPropertyName()`和`Object.keys()`时，只有`name`属性被返回。类似地，当在`proxy`上调用`Object.getOwnPropertySymbols()`时，只有`nameSymbol`被返回。`_name`属性在两个结果中都不出现，因为它被过滤掉了。
`ownKeys`陷阱也会影响`for-in`循环，它调用该陷阱来决定在循环内部返回哪些键。
## 使用`apply`和`construct`陷阱的函数代理
在所有代理陷阱中，只有`apply`和`construct`要求代理目标是一个函数。回忆第三章，函数有两个名为`[[Call]]`和`[[Construct]]`的内部方法，它们分别在函数不通过`new`操作符和通过`new`操作符调用时执行。`apply`和`construct`陷阱对应可以使你重写这些内部方法。当一个函数不使用`new`调用时，`apply`陷阱接收，`Reflect.apply()`期待以下参数：
1. `trapTarget` - 被执行的函数（代理的目标）
2. `thisArg` - 函数调用时内部的`this`值
3. `argumentsList` - 传递给函数的参数数组

`construct`陷阱将在使用new执行函数时被调用，它接收以下参数：
1. `trapTarget` - 被执行的函数（代理的目标）
2. `argumentsList` - 传递给函数的参数数组

`Reflect.construct()`方法也接收这两个参数，并有一个可选的名为`newTarget`的第三个参数。当给出时，`newTarget`参数指定函数中的`new.target`值。
两者结合，`apply`和`construct`陷阱完全控制了任何代理目标函数的行为。为了模拟函数的默认行为，你可以像下面这样做：
```js
let target = function() { return 42 },
    proxy = new Proxy(target, {
      apply: function(trapTarget, thisArg, argumentsList) {
        return Reflect.apply(trapTarget, thisArg, argumentsList);
      },
      construct: function(trapTarget, argumentsList) {
        return Reflect.construct(trapTarget, argumentsList);
      }
    });

// 一个函数的代理，因为它的目标看起来为函数
console.log(typeof proxy);         // "function"

console.log(proxy());              // 42

var instance = new proxy();
console.log(instance instanceof proxy);     // true
console.log(instance instanceof target);    // true
```
本例中有一个返回数字42的函数。该函数的代理使用`apply`和`construct`陷阱来将这些行为分别代理给`Reflect.apply()`和`Reflect.construct()`方法。最后的结果是代理函数和目标函数的工作方式完全相同，包括使用`typeof`来验证它是函数。代理在不用`new`调用时返回42，接着用`new`调用来创建一个名为`instance`的对象。`instance`对象被认为既是`proxy`又是`target`的实例，因为`instanceof`使用原型链来确定该信息。原型链检查没有被这个代理印象，因此`proxy`和`target`在JavaScript引擎中看起来有相同的原型。
### 函数参数校验
`apply`和`construct`陷阱为替换函数执行方式提供了新的可能。例如，假设你想要验证所有参数都是某个特定类型。你可以在`apply`陷阱中检查参数：
```js
// 将所有参数加在一起
function sum(...values) {
  return values.reduce((previous, current) => previous + current, 0);
}

let sumProxy = new Proxy(sum, {
  apply: function(trapTarget, thisArg, argumentsList) {
    argumentsList.forEach((arg) => {
      if (typeof arg !== "number") {
        throw new TypeError("All arguments must be numbers.");
      }
    });

    return Reflect.apply(trapTarget, thisArg, argumentsList);
  },
  construct: function(trapTarget, argumentsList) {
    throw new TypeError("This function can't be called with new.");
  }
});

console.log(sumProxy(1, 2, 3, 4));       // 10

// 抛出错误
console.log(sumProxy(1, "2", 3, 4));

// 也将抛出错误
let result = new sumProxy();
```
本例使用`apply`陷阱来确保所有参数都是数字。`sum()`函数将所有传入的参数求和。如果传入非数字值，函数也将尝试该操作，这将导致不可预料的结果。通过将`sum()`包裹在`sumProxy()`代理中，该代码拦截了函数调用并在允许调用处理前确保每个参数都为数字。为了安全，该代码同时使用`construct`陷阱来确保函数不会被`new`调用。
相反地，你也可以确保一个函数必须使用`new`调用并验证它的参数为数字：
```js
function Numbers(...values) {
  this.values = values;
}

let NumberProxy = new Proxy(Numbers, {
  apply: function(trapTarget, thisArg, argumentsList) {
    throw new TypeError("This function must be called with new.");
  },
  construct: function(trapTarget, argumentsList) {
    argumentsList.forEach((arg) => {
      if (typeof arg !== "number") {
        throw new TypeError("All arguments must be numbers.");
      }
    });

    return Reflect.construct(trapTarget, argumentsList);
  }
});

let instance = new NumberProxy(1, 2, 3, 4);
console.log(instance.values);      // [1,2,3,4]

// 抛出错误
NumberProxy(1, 2, 3, 4)
```
此处`apply`陷阱抛出一个错误而`construct`陷阱使用`Reflect.construct()`方法来验证输入并返回一个新的实例。当然，你也可以使用`new.target`而不用代理来实现相同的功能。
### 不使用new调用构造函数
第三章介绍了`new.target`元属性。回忆一下，`new.target`是使用`new`调用时函数的一个引用，表示你可以像下面一样通过检查`new.target`的值来判断一个函数是否是用`new`调用的：
```js
function Numbers(...values) {

  if (typeof new.target === "undefined") {
    throw new TypeError("This function must be called with new.");
  }

  this.values = values;
}

let instance = new Numbers(1, 2, 3, 4);
console.log(instance.values);             // [1, 2, 3, 4]

// 抛出错误
Numbers(1, 2, 3, 4);
```
本例当不使用`new`来调用Numbers时将抛出一个错误，这和“验证函数参数”一节中的例子相似，但并没有使用代理。这种写法比使用代理更简单并在你的唯一目的是避免使用`new`调用函数时更适合。但是有时你无法控制需要修改行为的函数。在这种情况下，使用代理将更有效。
假设`Numbers`函数定义在你无法修改的代码中。你知道该段代码依赖`new.target`并想要在避免这个检查的同时调用函数。使用`new`的行为已经被设定了，因此你只能使用`apply`陷阱：
```js
function Numbers(...values) {

  if (typeof new.target === "undefined") {
    throw new TypeError("This function must be called with new.");
  }

  this.values = values;
}

let NumbersProxy = new Proxy(Numbers, {
  apply: function(trapTarget, thisArg, argumentsList) {
    return Reflect.construct(trapTarget, argumentsList);
  }
});

let instance = NumbersProxy(1, 2, 3, 4);
console.log(instance.values);                   // [1, 2, 3, 4]
```
`NumbersProxy`函数允许你不使用`new`来调用`Numbers`，并使其行为与使用`new`一致。为了实现这点，使用`apply`陷阱与传入`apply`的参数来调用`Reflect.construct()`。`Numbers`内的`new.target`等于`Numbers`自身，不会抛出错误。虽然这是个修改`new.target`的简单例子，你也可以直接做更多。
### 覆盖抽象基类构造函数
你可以进一步为`Reflect.construct()`指定第三个参数作为赋给`new.target`的值。这在函数检查`new.target`是否为某已知值时很有用，例如创建一个抽象基类构造函数（第9章中讨论）。在抽象基类构造函数中，`new.target`应该是类构造函数自身以外的对象，如下面的例子：
```js
class AbstractNumbers {
  constructor(...values) {
    if (new.target === AbstractNumbers) {
      throw new TypeError("This function must be inherited from.");
    }

    this.values = values;
  }
}

class Numbers extends AbstractNumbers {}

let instance = new Numbers(1, 2, 3, 4);
console.log(instance.values);            // [1, 2, 3, 4]

// 抛出错误
new AbstractNumbers(1, 2, 3, 4);
```
当调用`new AbstractNumbers()`时，`new.target`等于`AbstractNumbers`，因此将抛出一个错误。调用`new Numbers()`依旧成功，因为`new.target`等于`Numbers`。你可以通过使用代理手动给`new.target`赋值来绕过这种限制：
```js
class AbstractNumbers {
  constructor(...values) {
    if (new.target === AbstractNumbers) {
      throw new TypeError("This function must be inherited from.");
    }

    this.values = values;
  }
}

let AbstractNumbersProxy = new Proxy(AbstractNumbers, {
  construct: function(trapTarget, argumentsList) {
    return Reflect.construct(trapTarget, argumentsList, function() {});
  }
});

let instance = new AbstractNumbersProxy(1, 2, 3, 4);
console.log(instance.values);     // [1, 2, 3, 4]
```
`AbstractNumbersProxy`使用`construct`陷阱来拦截`new AbstractNumbersProxy()`方法调用。接着，使用来自陷阱的参数调用`Reflect.construct()`方法，并添加一个空函数作为第三个参数。该空函数被用作构造函数内的`new.target`值。因为`new.target`不等于`AbstractNumbers`，不会抛出错误，构造函数执行完全。
### 可调用类构造函数
第9章解释了类构造函数必须使用`new`调用。这是因为类构造函数内部的`[[Call]]`方法被指定为抛出一个错误。但是代理可以拦截`[[Call]]`调用，表明你可以通过使用代理来有效创建可调用类构造函数。例如，如果你想要一个类构造函数不通过`new`使用，你可以使用`apply`陷阱来创建一个新的实例。下面为一些示例代码：
```js
class Person {
  constructor(name) {
    this.name = name;
  }
}

let PersonProxy = new Proxy(Person, {
  apply: function(trapTarget, thisArg, argumentsList) {
    return new trapTarget(...argumentsList);
  }
});

let me = PersonProxy("Nicholas");
console.log(me.name);                   // "Nicholas"
console.log(me instanceof Person);      // true
console.log(me instanceof PersonProxy); // true
```
`PersonProxy`对象是`Person`类构造函数的一个代理。类构造函数只是函数，因此它们在代理中使用时和函数行为相同。`apply`陷阱重写默认行为并返回一个`trapTarget`的实例，它等同于`Person`。（我在本例中使用`trapTarget`来展示无需手动指定类。）`argumentsList`通过使用扩展操作符被逐个传递给`trapTarget`。不使用`new`调用`PersonProxy()`返回了一个`Person`的实例，如果你试图不使用`new`调用`Person()`，构造函数仍将抛出一个错误。创建可调用类构造函数只能通过使用代理实现。
## 可撤销代理
通常，一个代理一旦被创建就无法与它的目标解绑。目前为止本章的所有例子使用的都是不可撤销代理。但是也存在你想要撤销一个代理，使得它无法继续被使用的场景。当你想要因为安全原因通过API来提供对象同时保持随时切断访问某些功能的能力时，你将发现可撤销代理很有用。
你可以通过`Proxy.revocable()`方法来创建可撤销代理，它与`Proxy`构造函数接收同样的参数——一个目标函数和代理处理器。返回值是一个有以下属性的对象：
1. `proxy` - 可撤销的代理对象
2. `revoke` - 调用撤销代理的函数

当`revoke()`函数被调用时，将无法通过`proxy`来执行更多的操作。任何试图通过可能触发代理陷阱的与代理对象的交互都将抛出一个错误。例如：
```js
let target = {
  name: "target"
};

let { proxy, revoke } = Proxy.revocable(target, {});

console.log(proxy.name);        // "target"

revoke();

// 抛出错误
console.log(proxy.name);
```
本例创建了一个可撤销代理。它使用析构来从`Proxy.revocable()`方法返回的对象上来为同名的`proxy`和`revoke`变量赋值。之后，`proxy`对象可以被当作一个不可撤销代理对象使用，所以`proxy.name`返回`"target"`，因为它被传给`target.name`。然而一旦调用了`revoke()`函数，`proxy`不再工作。试图访问`proxy.name`抛出一个错误，正如其它将触发`proxy`上的陷阱的操作一样。
## 解决数组问题
我在本章开始解释了在ECMAScript6之前为什么开发人员无法准确模拟JavaScript中数组的行为。代理和反射API允许你创建一个对象，当属性增加和移除时，它的行为与内置的`Array`类型完全相同。为了唤起记忆，下面的例子展示了代理帮助模拟的行为：
```js
let colors = ["red", "green", "blue"];

console.log(colors.length);        // 3

colors[3] = "black";

console.log(colors.length);        // 4
console.log(colors[3]);            // "black"

colors.length = 2;

console.log(colors.length);         // 2
console.log(colors[3]);             // undefined
console.log(colors[2]);             // undefined
console.log(colors[1]);             // "green"
```
本例中有两个特别重要的行为需要注意：
1. `length`属性当`colors[3]`赋值时增加到4
2. 当`length`属性被设为2时，数组中的最后两个元素被删除

这两个行为是准确重现内置数组如何工作所必须模拟的。下面的几节将描述如何创造一个可以准确模拟它们的对象。
### 数组索引检测
记住，对数组来说，为一个数字属性键赋值是一个特殊用例，因为它们与非数字键区别对待。ECMAScript6标准给出了如何判断一个属性键是否为数组索引的指导：
> 名为`P`的字符串索引当且仅当`ToString(ToUint32(P))`等于`P`且`ToUint32(P)`不等于2^32^-1时为一个数组索引。

该操作可由下面的JavasScript代码实现：
```js
function toUint32(value) {
  return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);
}

function isArrayIndex(key) {
  let numericKey = toUint32(key);
  return String(numericKey) == key && numericKey < (Math.pow(2, 32))
}
```
### 当新增元素时增加长度
### 减少长度时删除元素
### 实现MyArray类
## 将代理作为原型
### 在原型上使用`get`陷阱
### 在原型上使用`set`陷阱
### 在原型上使用`has`陷阱
### 作为类原型的代理
## 总结