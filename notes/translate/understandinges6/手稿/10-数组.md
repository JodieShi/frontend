# 数组能力改进
数组是一种基本的JavaScript对象。然而虽然JavaScript的其它方面都随着时间不断演进，数组却直到ECMAScript5中引入了几个使其更易于使用的方法之后才有所改变。ECMAScript6通过增加更多功能对数组进行了改进，如创建方法、一些有用的便利方法以及创建类型化数组的能力。
## 创建数组
在ECMAScript6之前，主要有两种方式来创建数组：`Array`构造函数和数组字面量语法。这两种方法都需要逐个列举数组元素，否则将很受限。将类数组对象（即具备数字索引和`length`属性的对象）转化为数组的选项也是有限的，并且经常需要额外代码。为了使JavaScript数组更容易创建，ECMAScript6增加了`Array.of()`和`Array.from()`方法。
### Array.of()方法
ECMAScript6向JavaScript中新增创建函数的一个原因是为了帮助开发者避免通过使用`Array`构造函数创建数组的怪异行为。`new Array()`构造函数实际上根据传入参数的类型和个数而有不同的行为。例如：
```js
let items = new Array(2);
console.log(items.length);    // 2
console.log(items[0]);         // undefined
console.log(items[1]);         // undefined

items = new Array("2");
console.log(items.length);    // 1
console.log(items[0]);        // "2"

items = new Array(1, 2);
console.log(items.length);    // 2
console.log(items[0]);        // 1
console.log(items[1]);        // 2

items = new Array(3, "2");
console.log(items.length);    // 2
console.log(items[0]);        // 3
console.log(items[1]);        // "2"
```
当`Array`构造函数传入单个数字值时，数组的`length`属性被设置为该值。如果传入一个非数字值，该值成为数组中的唯一元素。如果多个值（数值或非数值）传入，这些值成为数组中的元素。这类行为既迷惑又具风险，因为你可能并非总是关注到什么类型的数据被传入。
ECMAScript6引进了`Array.of()`来解决这个问题。`Array.of()`方法与`Array`构造函数工作方法相似，但是针对单个数字值传入并没有特殊用例。`Array.of()`方法总是创建一个包含其参数的数组，无论参数类型和参数个数。这里有几个使用`Array.of()`方法的例子：
```js
let items = Array.of(1, 2);
console.log(items.length);     // 2
console.log(items[0]);         // 1
console.log(items[1]);         // 2

items = Array.of(2);
console.log(items.length);     // 1
console.log(items[0]);         // 2

items = Array.of("2");
console.log(items.length);     // 1
console.log(items[0]);         // "2"
```
为了使用`Array.of()`方法创建一个数组，只需要向它传入数组中想要的值。这里的第一个例子创建了一个包含两个数字的数组，第二个数组包含一个数字，最后一个包含了一个字符串。这与使用数组字面量相似，在大多时候，你可以使用数组字面量而不是`Array.of()`来创建本地数组。但是如果你需要将Array构造函数传入一个函数，那么你可能想要传递`Array.of()`来保证行为的一致性。例如：
```js
function createArray(arrayCreator, value) {
  return arrayCreator(value);
}

let items = createArray(Array.of, value);
```
在这段代码中，`createArray()`函数接受一个数组构造函数和一个插入数组中的值。你可以向`createArray()`中传入`Array.of()`作为第一个参数来创建一个新的数组。直接传入`Array`可能是危险的，如果你无法保证`value`不是一个数字。
`Array.of()`方法不使用`Symbol.species`属性（第9章中讨论）来决定返回值的类型。取而代之，它使用当前构造函数（`of()`方法中的`this`）来决定正确的返回数据类型。
### Array.from()方法
将非数组对象转换为真实的数组在JavaScript中一直是麻烦的。例如，如果你有一个`arguments`对象（类数组）并且想把它当作数组使用，那么你需要先转换它。在ECMAScript5中，为了转换一个类数组对象，你可以编写下例中类似的函数：
```js
function makeArray(arrayLike) {
  var result = [];

  for (var i = 0, len = arrayLike.length; i < len; i++) {
    result.push(arrayLike[i]);
  }

  return result;
}

function doSomething() {
  var args = makeArray(arguments);

  // 使用args
}
```
该方法手动创建一个`result`数组并依次将`arguments`中元素拷贝到新数组中。这是有效的，但是需要一定的代码量来执行一个相对简单的操作。后来，开发人员发现他们可以在类数组对象上本地调用数组的`slice()`方法来减少代码量。如下；
```js
function makeArray(arrayLike) {
  return Array.prototype.slice.call(arrayLike);
}

function doSomething() {
  var args = makeArray(arguments);

  // 使用args
}
```
这段代码等效于前面的例子，因为它将`slice()`的`this`值设置为类数组对象而生效。由于`slice()`只需要数值索引和一个`length`属性来保证方法的正确性，类数组对象也将生效。
虽然该技术只需更少的代码，调用`Array.prototype.slice.call(arrayLike)`并不明显地等译于“转换`arrayLike`为一个数组”。幸运的是，ECMAScript6增加了`Array.from()`方法来作为显示的，同时干净的，将对象转换为数组的方法。
给定一个可迭代对象或一个类数组对象作为第一个参数。`Array.from()`方法返回一个数组。这里为一个简单例子：
```js
function doSomething() {
  var args = Array.from(arguments);

  // 使用args
}
```
`Array.from()`调用基于`arguments`中的元素创建了一个新的数组。因此`args`是一个包含了与`arguments`中相同位置相同值的`Array`实例。
`Array.from()`方法也使用`this`来决定返回的数组类型。
#### 映射转换
#### 在可迭代对象上使用
## 所有数组上的新方法
### find()和findIndex()方法
### fill()方法
### copyWithin()方法
## 类型化数组
### 数值数据类型
### 数组缓冲区
### 使用视图操作数组缓冲区
#### 获取视图信息
#### 数据读写
#### 作为视图的类型化数组
#### 创建指定类型视图
## 类型化数组和常规数组间的相似点
### 常见方法
### 相同的迭代器
### of()和from()方法
## 类型化数组和常规数组间的不同点
### 行为差异
### 缺少的方法
### 额外的方法
## 总结