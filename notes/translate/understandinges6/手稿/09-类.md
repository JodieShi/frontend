# JavaScript类介绍
不同于多数面向对象编程语言，JavaScript在创建时并不支持类和类继承作为定义相似或关联对象的首要方式。这迷惑了很多开发人员，从ECMAScript1之前一直到ECMAScript5，许多库都创建了使得JavaScript看起来像支持类的工具。虽然有些JavaScript开发人员强烈认为该语言不需要类，为了这个目的而特地创建的库数量导致ECMAScript6中包含了类。
虽然是探索ECMAScript6类，理解类使用的底层机制将有帮助，因此本章由讨论ECMAScript5开发者如何实现类行为开始。然而如你后续可见，ECMAScript6类并不是完全与其它语言中的类相同。它们有一个独特之处，即包含了JavaScript的动态特性。
## ECMAScript5中的类结构
在ECMAScript5及之前，JavaScript没有类。最接近于类的是创建一个构造函数，并给构造函数原型的方法赋值，这是通常被称为自定义类型的方法。例如：
```js
function PersonType(name) {
  this.name = name;
}

PersonType.prototype.sayName = function() {
  console.log(this.name);
};

let person = new PersonType("Nicholas");
person.sayName();    // 输出 "Nicholas"

console.log(person instanceof PersonType);   // true
console.log(person instanceof Object);   // true
```
在这段代码中，`PersonType`是一个构造函数，它创造了一个只有名为`name`的属性的实例。`sayName()`方法被赋给原型，因此`PersonType`对象的所有实例都共享同一个函数。接着，使用`new`操作符创建了一个新的`PersonType`实例。`person`对象通过原型继承被认为是`PersonType`和`Object`的实例。
这种基本模式是许多JavaScript类模拟库的基础，这也是ECMAScript6类的起点。
## 类声明
ECMAScript6中最简单的类形式为类声明，它与其它语言中类看起来相似。
### 一个基础类声明
类声明由关键字`class`开始，跟着类名。其它的语法看起来类似于对象字面量的简写方法，之间不需要逗号。例如，这里有一个简单的类声明：
```js
class PersonClass {
  // 等效于PersonType构造函数
  constructor(name) {
    this.name = name;
  }

  // 等效于PersonType.prototype.sayName
  sayName() {
    console.log(this.name);
  }
}

let person = new PersonClass("Nicholas");
person.sayName();     // 输出 "Nicholas"

console.log(person instanceof PersonClass);   // true
console.log(person instanceof Object);        // true

console.log(typeof PersonClass);    // "function"
console.log(typeof PersonClass.prototype.sayName);    // "function"
```
类声明`PersonClass`的行为与前例中的`PersonType`十分相似。然而不同于定义一个函数作为构造函数，类声明允许你直接在类内部使用一个特殊的`constructor`方法名定义构造函数。由于类方法使用简写语法，因此不需要使用`function`关键字。其它方法名没有特殊的意义，因此你可以按你所想增加更多的方法。
*自有属性*，在实例上而不是在原型上的属性，只能在一个类的构造函数或方法中被创建。在这个例子中，`name`是一个自有属性。我建议在构造函数中创建所有可能的自有属性，这样类中的一个单独位置负责所有这些。
有趣的是，类声明只是已有自定义类型声明的语法糖。`PersonClass`声明实际上创建了一个具有`constructor`方法行为的函数，这也是为什么`typeof PersonClass`的结果是`"function"`。`sayName()`方法也在本例中成为`PersonClass.prototype`上的一个方法，类似于前例中`sayName()`和`PersonType.prototype`间的关系。这些相似点使得你可以混用自定义类型和类而无需过于考虑你在用什么。
### 为什么使用类语法
除了类和自定义类型之间的这些相似点，还需记住一些重要的不同点：
1. 类声明，不同于函数声明，不会被提升。类声明与`let`声明相似，因此直到执行到声明之前都存在于暂时性死区中。
2. 类声明中的所有代码都自动执行在严格模式下。没有在类中退出严格模式的方法。
3. 所有方法都是不可枚举的。这是一个明显的与自定义类型的差别，你需要使用`Object.defineProperty()`来使一个方法不可枚举。
4. 所有方法都缺少内部的`[[Construct]]`方法，并将在你想要使用`new`来调用它们时抛出一个错误。
5. 不使用`new`调用类构造函数将抛出一个错误。
6. 试图在一个类方法中改写类名将抛出一个错误。
知道这些，前例中的PersonClass声明直接等效于以下代码，它未使用类语法：
```js
// 直接等效于PersonClass
let PersonType2 = (function() {
  "use strict";

  const PersonType2 = function(name) {

    // 确保该函数由new调用
    if (typeof new.target === "undefined") {
      throw new Error("Constructor must be called with new.");
    }

    this.name = name;
  }

  Object.defineProperty(PersonType2.prototype, "sayName", {
    value: function() {

      // 确保方法不是由new调用的
      if (typeof new.target !== "undefined") {
        throw new Error("Method cannot be called with new.");
      }

      console.log(this.name);
    },
    enumerable: false,
    writable: true,
    configurable: true
  });

  return PersonType2;
}());
```
首先，注意到有两个`PersonType2`声明：一个外部作用域的`let`声明和一个IIFE内的`const`声明。这是类方法禁止重写类名而类外部代码可以的实现方式。构造函数检查`new.target`来确保它由`new`调用；如果不是，将抛出一个错误。接着，`sayName()`方法被定义为不可枚举的，该方法检查`new.target`来确保它不是由`new`调用的。最后一步返回构造函数。
这个例子展示了虽然不使用任何新语法也可以完成所有事，类语法大大简化了这些功能。
### 常量类名
类名只有像在类内部使用`const`一样指定。这表明你只可以在类外部重写类名而无法在类方法内部重写。例如：
```js
class Foo {
  constructor() {
    Foo = "bar";   // 执行时抛出一个错误
  }
}

// 但在类声明外是可以的
Foo = "baz";
```
在这段代码中，类构造函数内的`Foo`是一个独立于类外部`Foo`的绑定。内部`Foo`被当作是`const`一般定义，并且不能被重写。当构造函数试图用任何值重写`Foo`时将抛出一个错误。但是由于外部`Foo`被当作是一个`let`声明，因此你可以在任何时候改写它。
## 类表达式
类和函数的相似之处在于它们有两种形式：声明和表达式。函数和类定义以合适的关键字开始（分别是`function`或`class`），接着是标识符。函数有一个不需要标识符的表达式形式，类似地，类有一个`class`之后不需要标识符的表达式形式。*类表达式*被设计用来在变量声明中使用或作为函数参数传入。
### 一个基础类表达式
这里有一个等效于之前的`PersonClass`例子的类表达式，以及一些使用它的代码：
```js
let PersonClass = class {

  // 等效于PersonType构造函数
  constructor(name) {
    this.name = name
  }

  // 等效于PersonType.prototype.sayName
  sayName() {
    console.log(this.name);
  }
};

let person = new PersonClass("Nicholas");
person.sayName();     // "Nicholas"

console.log(person instanceof PersonClass);   // true
console.log(person instanceof Object);        // true

console.log(typeof PersonClass);    // "function"
console.log(typeof PersonClass.prototype.sayName);    // "function"
```
如本例所示，类表达式不要求`class`之后有标识符。除了语法，类表达式与类声明的功能相同。
使用类声明或类表达式多数只是风格问题。不同于函数声明和函数表达式，类声明和类表达式都不会被提升，所以选择很少依赖于代码的运行时行为。
### 命名类表达式
上一节例子中使用了匿名类表达式，正如函数表达式，你也可以使用命名类表达式。为此，你需要如下在`class`关键字之后增加一个标识符：
```js
let PersonClass = class PersonClass2 {

  // 等效于PersonType构造函数
  constructor(name) {
    this.name = name
  }

  // 等效于PersonType.prototype.sayName
  sayName() {
    console.log(this.name);
  }
};

console.log(typeof PersonClass);    // "function"
console.log(typeof PersonClass2);    // "undefined"
```
在这个例子中，类表达式被命名为`PersonClass2`。`PersonClass2`标识符只在类定义中存在，因此它可以在类方法（如本例中的`sayName()`方法）中使用。在类外，`typeof PersonClass2`为`"undefined"`，因为不存在`PersonClass2`绑定。为了理解为什么是这样，可以看一个不使用类的等效声明：
```js
// PersonClass命名类表达式的直接等效声明
let PersonClass = (function() {
  "use strict";

  const PersonClass2 = function(name) {

    // 确保函数由new调用
    if (typeof new.target === "undefined") {
      throw new Error("Constructor must be called with new.");
    }

    this.name = name;
  }

  Object.defineProperty(PersonClass2.prototype, "sayName", {
    value: function() {
      // 确保方法不是由new调用的
      if (typeof new.target !== "undefined") {
        throw new Error("Method cannot be called with new.");
      }
      
      console.log(this.name);
    },
    enumerable: false,
    writable: true,
    configurable: true
  })

  return PersonClass2;
}());
```
创建一个命名类表达式稍微改变了JavaScript引擎中正发生的。对于类声明，外部绑定（由`let`定义）与内部绑定（由`const`定义）同名。一个命名类表达式在`const`定义中使用自己的名字，因此`PersonClass2`只在类内部定义使用。
虽然命名类表达式和命名函数表达式行为不同，两者之间仍有许多相似点。它们都可以被用作值，这启发了许多新的可能性，我将在下面介绍。
## 作为一等公民的类
在编程中，当某物可以被用作值时，它被称为*一等公民*，表明它可以被传入函数，从函数返回并赋值给一个变量。JavaScript函数为一等公民（有时它们仅被称为一等类函数），这也是使得JavaScript独特的一部分。
ECMAScript6通过使得类成为一等公民而延续了这个传统。这允许用多种方式使用类。例如，它们可以被传入函数作为参数：
```js
function createObject(classDef) {
  return new classDef();
}

let obj = createObject(class {

  sayHi() {
    console.log("Hi!");
  }
});

obj.sayHi();     // "Hi"
```
在这个例子中，`createObject()`函数与一个匿名类表达式参数一起被调用，通过`new`创建了一个该类的实例，并返回该实例。变量`obj`接着存储并返回了这个实例。
另一个类表达式的有趣用法是通过立即调用类构造函数创建单例。为此你必须用`new`使用类表达式并在末尾加上括号。例如：
```js
let person = new class {

  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}("Nicholas");

person.sayName();          // "Nicholas"
```
此处，创建了一个匿名类表达式并立即执行它。这个模式允许你使用类语法创建单例而无需遗留一个可访问的类引用。（记住，`PersonClass`只在类内部创建绑定，而不在外部。）类表达式尾部的括号表明你正在调用这个函数，同时允许你传递参数。
目前本章的例子只关注于类及其上的方法。你也可以在类上使用类似于对象字面量的语法创建访问器属性。
## 访问器属性
虽然自有属性应该被在类构造函数内被创建，类允许你在原型上定义访问器属性。为了创建一个getter函数，需要使用关键字`get`，跟着一个空格和一个标识符；为了创建一个setter函数，需要用关键字`set`做相同的事。例如：
```js
class CustomHTMLElement {

  constructor(element) {
    this.element = element;
  }

  get html() {
    return this.element.innerHTML;
  }

  set html(value) {
    this.element.innerHTML = value;
  }
}

var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html");
console.log("get" in descriptor);   // true
console.log("set" in descriptor);   // true
console.log(descriptor.enumerable);   // false
```
在这段代码中，`CustomHTMLElement`类被用作已有DOM元素的包装器。它有一个`html`的`getter`函数和`setter`函数，并代理给元素自身的`innerHTML`属性。访问器属性被创建在`CustomHTMLElement`上，正如其它方法，被创建为不可枚举的。等效的非类表示为：
```js
// 直接等效于前例
let CustomHTMLElement = (function() {
  "use strict";

  const CustomHTMLElement = function(element) {

    // 确保函数由new调用
    if (typeof new.target === "undefined") {
      throw new Error("Constructor must be called with new.");
    }

    this.element = element;
  }

  Object.defineProperty(CustomHTMLElement.prototype, "html", {
    enumerable: false,
    configurable: true,
    get: function() {
      return this.element.innerHTML;
    },
    set: function(value) {
      this.element.innerHTML = value;
    }
  });

  return CustomHTMLElement;
}());
```
如前例所示，本例展示了使用类比不使用类可以节省多少代码。`html`访问器属性定义自身几乎与等效类定义大小相同。
## 计算成员名称
对象字面量和类之间的相似点不只是这些。类方法和访问器属性可以有计算名。不使用标识符而在表达式周围使用方括号，这与对象字面量的计算命名语法相同。例如：
```js
let methodName = "sayName";

class PersonClass {
  constructor(name) {
    this.name = name;
  }

  [methodName]() {
    console.log(this.name);
  }
}

let me = new PersonClass("Nicholas");
me.sayName();          // "Nicholas"
```
这个版本的`PersonClass`使用一个变量来为其定义内部的方法命名。字符串`"sayName"`被赋给`methodName`变量，接着`methodName`被用来声明该方法。`sayName()`方法稍后可直接访问。
访问器属性同样可以使用计算名，如下：
```js
let propertyName = "html";

class CustomHTMLElement {

  constructor(element) {
    this.element = element;
  }

  get [propertyName]() {
    return this.element.innerHTML;
  }

  set [propertyName](value) {
    this.element.innerHTML = value;
  }
}
```
此处，`html`的`getter`函数和`setter`函数都是用`propertyName`变量设置。使用`.html`访问该属性只影响定义。
你已经认识到类和对象字面量之间有很多相似点，如方法，访问器属性和计算名。仍有另一个相似点需要包含：生成器。
## 生成器方法
当第8章介绍生成器时，你已经知道如何在一个对象字面量上通过在方法名前缀星号（`*`）定义一个生成器。相同语法也适用于类，使得任何方法成为一个生成器。这里有一个例子：
```js
class MyClass {

  *createIterator {
    yield 1;
    yield 2;
    yield 3;
  }

}

let instance = new MyClass();
let iterator = instance.createIterator();
```
这段代码创建了一个具有`createIterator()`生成器方法的`MyClass`类。该方法返回一个迭代器，它的值被硬编码至生成器中。生成器方法在你有一个表示集合值的对象并想要迭代这些值的时候很有用。考虑到开发人员与数据项交互的不同方式，数组，集合和映射都有多个生成器方法。
虽然生成器方法很有用，如果你的类表示值的集合，那么为该类定义一个默认迭代器更有效。你可以通过使用`Symbol.iterator`定义生成器方法来为类定义默认迭代器，例如：
```js
class Collection {

  constructor() {
    this.items = [];
  }

  *[Symbol.iterator]() {
    yield *this.items.values();
  }
}

var collection = new Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
  console.log(x);
}

// 输出
// 1
// 2
// 3
```
本例使用一个计算名将生成器方法代理给`this.items`的`values()`迭代器。任何管理集合值的类都应该包含一个默认迭代器，因为一些集合特性操作要求它们操作的集合有一个迭代器。现在，任何`Collection`的实例都可以直接在`for-of`循环中使用，或使用扩展操作符。
为类原型新增一些方法和访问器属性在你想要它们出现在对象实例上时是有效的。如果想要方法和访问器属性出现在类自身上，你需要使用静态成员。
## 静态成员
在ECMAScript5及之前，直接向构造器中添加方法来模拟静态成员是另一个常见的模式。例如：
```js
function PersonType(name) {
  this.name = name;
}

// 静态方法
PersonType.create = function(name) {
  return new PersonType(name);
};

// 实例方法
PersonType.prototype.sayName = function() {
  console.log(this.name);
};

var person = PersonType.create("Nicholas");
```
在其它编程语言中，被称为`PersonType.create()`的工厂方法被认为是静态方法，它不依赖于`PersonType`的实例数据。ECMAScript6类通过在方法或访问器属性前增加正式的`static`描述符来简化静态成员的创建。例如，这里有一个上述例子的等效类：
```js
class PersonClass {
  // 等效于PersonType构造函数
  constructor(name) {
    this.name = name;
  }

  // 等效于PersonType.prototype.sayName
  sayName() {
    console.log(this.name);
  }

  // 等效于PersonType.create
  static create(name) {
    return new PersonClass(name);
  }
}

let person = PersonClass.create("Nicholas");
```
`PersonClass`定义有一个名为`create()`静态方法。该方法的语法除了`static`关键字外与`sayName()`相同。你可以在类中的任何方法或访问器属性定义前使用`static`关键字。唯一限制是你不能在`constructor`方法定义中使用`static`。
静态成员无法从实例上访问。你必须总是直接用类来访问静态成员。
## 派生类继承
在ECMAScript6之前，实现自定义类型继承是一个巨大的工程。适当的继承需要多个步骤。例如，考虑以下代码：
```js
function Rectangle(length, width) {
  this.length = length;
  this.width = width;
}

Rectangle.prototype.getArea = function() {
  return this.length * this.width;
};

function Square(length) {
  Rectangle.call(this, length, length);
}

Square.prototype = Object.create(Rectangle.prototype, {
  constructor: {
    value: Square,
    enumerable: false,
    writable: true,
    configurable: true
  }
});

var square = new Square(3);

console.log(square.getArea());               // 9
console.log(square instanceof Square);       // true
console.log(square instanceof Rectangle);    // true
```
`Square`继承自`Rectangle`，因此，你必须使用一个`Rectangle.prototype`创建的对象重写`Square.prototype`，并调用`Rectangle.call()`方法。这些步骤经常会迷惑新JavaScript开发者，并成为许多有经验开发者的错误来源。
类通过使用熟悉的`extends`关键字来指定该类应该继承自的函数，从而使得继承更易于实现。原型默认被调整，你可也通过调用`super()`方法来访问基础的类构造函数。下面为前例的ECMAScript6等效做法：
```js
class Rectangle {
  constructor(length, width) {
    this.length = length;
    this.width = width;
  }

  getArea() {
    return this.length * this.width;
  }
}

class Square extends Rectangle {
  constructor(length) {

    // 与Rectangle.call(this, length, length)相同
    super(length, length)
  }
}

var square = new Square(3);

console.log(square.getArea());               // 9
console.log(square instanceof Square);       // true
console.log(square instanceof Rectangle);    // true
```
这次，`square`类使用`extends`关键字继承`Rectangle`。`Square`构造函数使用`super()`来用特定参数调用`Rectangle`构造函数。注意，不同于ECMAScript5版本的代码，标识符`Rectangle`只在类声明中使用（`extends`之后）。
继承自其它类的类被引用为*派生类*。派生类要求你如果指定构造函数，那么需要用`super()`，没有使用的话会出现错误。如果你选择不使用构造函数，那么`super()`将自动调用，使用创建该类实例时的所有参数。例如，下面的两个类等效：
```js
class Square extends Rectangle {
  // 无构造函数
}

// 等效于
class Square extends Rectangle {
  constructor(...args) {
    super(...args);
  }
}
```
本例中的第二个类展示了所有派生类的默认构造函数的等效代码。所有参数都按基础类构造函数的顺序被传入。在这个例子中，这个功能并不完全正确，因为`Square`构造函数只需要一个参数，因此最好手动定义构造函数。
当使用`super()`时，有更多的一些事需要记住：
1. 你只能在一个派生类中使用`super()`。如果你试图在一个非派生类或函数中使用它（并未使用`extends`关键字的类），那么将抛出一个错误。
2. 你必须在构造函数访问`this`之前调用`super()`。由于`super()`负责初始化`this`，试图在调用`super()`之前访问`this`将导致一个错误。
3. 唯一避免调用`super()`的方法是从类构造函数中返回一个对象。
### 隐藏类方法
派生类的方法总是会隐藏基类上的同名方法。例如，你可以在Square上添加一个getArea()来重定义这个方法：
```js
class Square extends Rectangle {
  constructor(length) {
    super(length, length);
  }

  // 重写并隐藏Rectangle.prototype.getArea()
  getArea() {
    return this.length * this.length;
  }
}
```
由于`getArea()`作为`Square`的一部分定义，`Rectangle.prototype.getArea()`将不再会被`Square`的任何实例调用。当然，你可以使用`super.getArea()`方法来决定调用基类版本的方法，如下：
```js
class Square extends Rectangle {
  constructor(length) {
    super(length, length);
  }

  // 重写并隐藏Rectangle.prototype.getArea()
  getArea() {
    return super.getArea();
  }
}
```
如此使用`super`和使用第4章中讨论过的super引用是相同的（见“使用super引用快速访问原型”）。this值被自动正确设置，你可以方便进行调用方法。
### 继承静态成员
### 表达式派生类
### 内置继承
### Symbol.species属性
## 在类构造函数中使用new.target
## 总结